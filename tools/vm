#! /usr/bin/env python

import patch

import optparse
import os
import signal
import sys
import time
import threading

import cpu
import cpu.assemble
import console
import core
import irq
import irq.timer
import irq.conio
import io_handlers
import io_handlers.conio
import mm
import util
import machine
import profiler

from util import *

def main():
  parser = optparse.OptionParser()

  # Output
  opt_group = optparse.OptionGroup(parser, 'Output options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-l', '--logfile',
                       dest = 'logfile',
                       action = 'store',
                       default = None,
                       help = 'Log file')

  # Machine hardware
  opt_group = optparse.OptionGroup(parser, 'Machine hardware')
  parser.add_option_group(opt_group)
  opt_group.add_option('-c', '--cpus',
                       dest = 'cpus',
                       action = 'store',
                       default = 1,
                       help = 'Number of CPUs')
  opt_group.add_option('-t', '--cores',
                       dest = 'cores',
                       action = 'store',
                       default = 1,
                       help = 'Number of cores per CPU')
  opt_group.add_option('-s', '--storage',
                       dest = 'storages',
                       action = 'append',
                       default = [],
                       help = 'Storage device')

  opt_group.add_option('-m', '--mmap',
                       dest = 'mmaps',
                       action = 'append',
                       default = [],
                       metavar = 'file:address:size[:offset[:access[:shared]]][,...]',
                       help = 'Map file into memory')

  opt_group.add_option('--machine-out',
                       dest = 'machine_out',
                       action = 'store',
                       default = None,
                       metavar = 'FILE',
                       help = 'Log machine output into FILE')
  opt_group.add_option('--machine-in',
                       dest = 'machine_in',
                       action = 'append',
                       default = [],
                       metavar = 'FILE',
                       help = 'Read machine input from FILE')

  # Binary files
  opt_group = optparse.OptionGroup(parser, 'Binary files')
  parser.add_option_group(opt_group)
  opt_group.add_option('-i', '--irq',
                       dest = 'irq_routines',
                       action = 'store',
                       default = None,
                       help = 'Bytecode file with IRQ routines')
  opt_group.add_option('-b', '--binary',
                       dest = 'binaries',
                       action = 'append',
                       default = None,
                       help = 'Binary file to run')

  # Debug options
  opt_group = optparse.OptionGroup(parser, 'Debug options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-B', '--breakpoint',
                       dest = 'breakpoints',
                       action = 'append',
                       default = [],
                       help = 'Insert breakpoint at address')
  opt_group.add_option('-d', '--debug',
                       dest = 'debug',
                       action = 'store_true',
                       default = False,
                       help = 'Debug mode')
  opt_group.add_option('-g', '--go-on',
                       dest = 'go_on',
                       action = 'store_true',
                       default = False,
                       help = 'Don\'t wait for user to start binaries with pressing Enter')
  opt_group.add_option('-p', '--profile',
                       dest = 'profile',
                       action = 'store_true',
                       default = False,
                       help = 'Run with profiler')

  options, args = parser.parse_args()

  if options.profile == True:
    profiler.STORE.enable()

  main_profiler = profiler.STORE.get_profiler()
  main_profiler.enable()

  M = machine.Machine()

  util.CONSOLE = console.Console(M, sys.stdin, sys.stdout)
  util.CONSOLE.boot()

  if options.logfile:
    util.CONSOLE.set_logfile(options.logfile)

  M.hw_setup(cpus = int(options.cpus),
             cores = int(options.cores),
             binaries = options.binaries,
             storages = options.storages,
             irq_routines = options.irq_routines,
             breakpoints = options.breakpoints,
             mmaps = options.mmaps,
             machine_in = options.machine_in,
             machine_out = options.machine_out)

  def signal_handler(sig, frame):
    if sig == signal.SIGUSR1:
      info('VM suspended by user')
      M.suspend()

    elif sig == signal.SIGUSR2:
      info('VM unsuspended by user')
      M.wake_up()

    elif sig == signal.SIGINT:
      info('VM halted by user')
      M.halt()

    elif sig == signal.SIGSEGV:
      info('Generate VM coredump')

      state = core.VMState.capture_vm_state(M)

      filename = '/tmp/ducky-core.%s' % os.getpid()
      state.save(filename)

  signal.signal(signal.SIGINT,  signal_handler)
  signal.signal(signal.SIGUSR1, signal_handler)
  signal.signal(signal.SIGUSR2, signal_handler)
  signal.signal(signal.SIGSEGV, signal_handler)
  signal.signal(signal.SIGPIPE, signal_handler)

  M.boot()

  info('Press Enter to start execution of loaded binaries')
  util.CONSOLE.wait_on_line()

  M.run()
  M.wait()

  import tabulate

  table_exits = [
    ['Core', 'Exit code']
  ]

  table_inst_caches = [
    ['Core', 'Reads', 'Inserts', 'Hits', 'Misses', 'Prunes']
  ]

  def __check_stats(core):
    table_exits.append([str(core), core.exit_code])

    table_inst_caches.append([
      str(core),
      core.instruction_cache.reads,
      core.instruction_cache.inserts,
      core.instruction_cache.hits,
      core.instruction_cache.misses,
      core.instruction_cache.prunes
    ])

  M.for_each_core(__check_stats)

  for line in tabulate.tabulate(table_exits, headers = 'firstrow', tablefmt = 'simple', numalign = 'right').split('\n'):
    info(line)

  info('')

  for line in tabulate.tabulate(table_inst_caches, headers = 'firstrow', tablefmt = 'simple', numalign = 'right').split('\n'):
    info(line)

  main_profiler.disable()

  profiler.STORE.save('profile')

  sys.exit(M.exit_code)

if __name__ == '__main__':
  main()

