#! /usr/bin/env python

import os
import sys

if os.environ.get('DUCKY_IMPORT_DEVEL', 'no') == 'yes':
  sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))

import optparse
import signal

import ducky.patch
import ducky.config
import ducky.console
import ducky.machine
import ducky.reactor
import ducky.util
import ducky.profiler
import ducky.snapshot

from ducky.util import print_table, info

def main():
  parser = optparse.OptionParser()

  # Output
  opt_group = optparse.OptionGroup(parser, 'Output options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-l', '--logfile',
                       dest = 'logfile',
                       action = 'store',
                       default = None,
                       help = 'Log file')

  # Machine configuration
  opt_group = optparse.OptionGroup(parser, 'Machine hardware')
  parser.add_option_group(opt_group)
  opt_group.add_option('--machine-config',
                       dest = 'machine_config',
                       action = 'store',
                       default = None,
                       help = 'Path to machine configuration file')
  opt_group.add_option('--machine-out',
                       dest = 'machine_out',
                       action = 'store',
                       default = None,
                       metavar = 'FILE',
                       help = 'Log machine output into FILE')
  opt_group.add_option('--machine-in',
                       dest = 'machine_in',
                       action = 'append',
                       default = [],
                       metavar = 'FILE',
                       help = 'Read machine input from FILE')
  opt_group.add_option('--conio-echo',
                       dest = 'conio_echo',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'yes')
  opt_group.add_option('--conio-console',
                       dest = 'conio_console',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'yes')
  opt_group.add_option('--conio-highlight',
                       dest = 'conio_highlight',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'no')
  opt_group.add_option('--conio-stdout-echo',
                       dest = 'conio_stdout_echo',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'no')
  opt_group.add_option('--machine-profile',
                       dest = 'machine_profile',
                       action = 'store_true',
                       default = False,
                       help = 'Enable profiling of running binaries')

  # Debug options
  opt_group = optparse.OptionGroup(parser, 'Debug options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-d', '--debug',
                       dest = 'debug',
                       action = 'store_true',
                       default = False,
                       help = 'Debug mode')
  opt_group.add_option('-g', '--go-on',
                       dest = 'go_on',
                       action = 'store_true',
                       default = False,
                       help = 'Don\'t wait for user to start binaries with pressing Enter')
  opt_group.add_option('-p', '--profile',
                       dest = 'profile',
                       action = 'store_true',
                       default = False,
                       help = 'Enable profiling of the whole virtual machine')
  opt_group.add_option('-P', '--profile-dir',
                       dest = 'profile_dir',
                       action = 'store',
                       default = None,
                       help = 'Store profiling data in this directory')

  options, args = parser.parse_args()

  if options.profile:
    profiler.STORE.enable_machine()

  if options.machine_profile:
    profiler.STORE.enable_cpu()

  main_profiler = ducky.profiler.STORE.get_machine_profiler()
  main_profiler.enable()

  M = ducky.machine.Machine()

  ducky.util.CONSOLE = ducky.console.Console(M, sys.stdin, sys.stdout)
  ducky.util.CONSOLE.boot()
  ducky.util.CONSOLE.set_quiet_mode(not options.debug)

  if options.logfile:
    ducky.util.CONSOLE.set_logfile(options.logfile)

  machine_config = ducky.config.MachineConfig()
  machine_config.read(options.machine_config)

  M.hw_setup(machine_config,
             machine_in = options.machine_in,
             machine_out = options.machine_out)

  M.conio.stdout_echo = True if options.conio_stdout_echo == 'yes' else False
  M.conio.echo = True if options.conio_echo == 'yes' else False
  M.conio.open_console = True if options.conio_console == 'yes' else False
  M.conio.highlight = True if options.conio_highlight == 'yes' else False

  def signal_handler(sig, frame):
    if sig == signal.SIGUSR1:
      info('VM suspended by user')
      reactor.reactor.add_call(M.suspend)

    elif sig == signal.SIGUSR2:
      info('VM unsuspended by user')
      reactor.reactor.add_call(M.wake_up)

    elif sig == signal.SIGINT:
      info('VM halted by user')
      reactor.reactor.add_call(M.halt)

    elif sig == signal.SIGSEGV:
      info('VM snapshot requested')
      reactor.reactor.add_call(M.snapshot('ducky-snapshot-user.bin'))

  signal.signal(signal.SIGINT,  signal_handler)
  signal.signal(signal.SIGUSR1, signal_handler)
  signal.signal(signal.SIGUSR2, signal_handler)
  signal.signal(signal.SIGSEGV, signal_handler)

  M.boot()

  if not options.go_on:
    info('Press Enter to start execution of loaded binaries')
    util.CONSOLE.wait_on_line()

  M.run()  # reactor loop!

  state = ducky.snapshot.VMState.capture_vm_state(M, suspend = False)
  state.save('ducky-snapshot.bin')
  info('VM snapshot save in ducky-snapshot.bin')

  table_exits = [
    ['Core', 'Exit code']
  ]

  table_inst_caches = [
    ['Core', 'Reads', 'Inserts', 'Hits', 'Misses', 'Prunes']
  ]
  table_data_caches = [
    ['Core', 'Reads', 'Inserts', 'Hits', 'Misses', 'Prunes']
  ]

  def __check_stats(core):
    table_exits.append([str(core), core.exit_code])

    table_inst_caches.append([
      str(core),
      core.instruction_cache.reads,
      core.instruction_cache.inserts,
      core.instruction_cache.hits,
      core.instruction_cache.misses,
      core.instruction_cache.prunes
    ])

    table_data_caches.append([
      str(core),
      core.data_cache.reads,
      core.data_cache.inserts,
      core.data_cache.hits,
      core.data_cache.misses,
      core.data_cache.prunes
    ])

  map(__check_stats, M.cores())

  info('Exit codes')
  print_table(table_exits)
  info('')
  info('Instruction caches')
  print_table(table_inst_caches)
  info('')
  info('Data caches')
  print_table(table_data_caches)
  info('')

  main_profiler.disable()

  if options.profile or options.machine_profile:
    info('Saving profiling data into %s' % options.profile_dir)
    ducky.profiler.STORE.save(options.profile_dir)

  sys.exit(M.exit_code)

if __name__ == '__main__':
  main()
