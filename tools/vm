#! /usr/bin/env python

import patch

import optparse
import os
import signal
import sys
import time

import config
import cpu
import cpu.assemble
import console
import core
import irq
import irq.timer
import irq.conio
import io_handlers
import io_handlers.conio
import mm
import util
import machine
import profiler

from util import *
from util import print_table

def main():
  parser = optparse.OptionParser()

  # Output
  opt_group = optparse.OptionGroup(parser, 'Output options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-l', '--logfile',
                       dest = 'logfile',
                       action = 'store',
                       default = None,
                       help = 'Log file')

  # Machine configuration
  opt_group = optparse.OptionGroup(parser, 'Machine hardware')
  parser.add_option_group(opt_group)
  opt_group.add_option('--machine-config',
                       dest = 'machine_config',
                       action = 'store',
                       default = None,
                       help = 'Path to machine configuration file')
  opt_group.add_option('--machine-out',
                       dest = 'machine_out',
                       action = 'store',
                       default = None,
                       metavar = 'FILE',
                       help = 'Log machine output into FILE')
  opt_group.add_option('--machine-in',
                       dest = 'machine_in',
                       action = 'append',
                       default = [],
                       metavar = 'FILE',
                       help = 'Read machine input from FILE')
  opt_group.add_option('--conio-echo',
                       dest = 'conio_echo',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'yes')
  opt_group.add_option('--conio-console',
                       dest = 'conio_console',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'yes')
  opt_group.add_option('--conio-highlight',
                       dest = 'conio_highlight',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'no')
  opt_group.add_option('--conio-stdout-echo',
                       dest = 'conio_stdout_echo',
                       action = 'store',
                       type = 'choice',
                       choices = ['yes', 'no'],
                       default = 'no')
  opt_group.add_option('--machine-profile',
                       dest = 'machine_profile',
                       action = 'store_true',
                       default = False,
                       help = 'Enable profiling of runningbinaries')

  # Debug options
  opt_group = optparse.OptionGroup(parser, 'Debug options')
  parser.add_option_group(opt_group)
  opt_group.add_option('-d', '--debug',
                       dest = 'debug',
                       action = 'store_true',
                       default = False,
                       help = 'Debug mode')
  opt_group.add_option('-g', '--go-on',
                       dest = 'go_on',
                       action = 'store_true',
                       default = False,
                       help = 'Don\'t wait for user to start binaries with pressing Enter')
  opt_group.add_option('-p', '--profile',
                       dest = 'profile',
                       action = 'store_true',
                       default = False,
                       help = 'Enable profiling of the whole virtual machine')

  options, args = parser.parse_args()

  if options.profile == True:
    profiler.STORE.enable_machine()

  if options.machine_profile == True:
    profiler.STORE.enable_cpu()

  main_profiler = profiler.STORE.get_machine_profiler()
  main_profiler.enable()

  M = machine.Machine()

  util.CONSOLE = console.Console(M, sys.stdin, sys.stdout)
  util.CONSOLE.boot()

  if options.logfile:
    util.CONSOLE.set_logfile(options.logfile)

  machine_config = config.MachineConfig()
  machine_config.read(options.machine_config)

  M.hw_setup(machine_config,
             machine_in = options.machine_in,
             machine_out = options.machine_out)

  M.conio.stdout_echo = True if options.conio_stdout_echo == 'yes' else False
  M.conio.echo = True if options.conio_echo == 'yes' else False
  M.conio.open_console = True if options.conio_console == 'yes' else False
  M.conio.highlight = True if options.conio_highlight == 'yes' else False

  def signal_handler(sig, frame):
    if sig == signal.SIGUSR1:
      info('VM suspended by user')
      M.suspend()

    elif sig == signal.SIGUSR2:
      info('VM unsuspended by user')
      M.wake_up()

    elif sig == signal.SIGINT:
      info('VM halted by user')
      M.halt()

    elif sig == signal.SIGSEGV:
      info('Generate VM coredump')

      state = core.VMState.capture_vm_state(M)

      filename = '/tmp/ducky-core.%s' % os.getpid()
      state.save(filename)

  signal.signal(signal.SIGINT,  signal_handler)
  signal.signal(signal.SIGUSR1, signal_handler)
  signal.signal(signal.SIGUSR2, signal_handler)
  signal.signal(signal.SIGSEGV, signal_handler)
  signal.signal(signal.SIGPIPE, signal_handler)

  M.boot()

  if not options.go_on:
    info('Press Enter to start execution of loaded binaries')
    util.CONSOLE.wait_on_line()

  M.run()
  M.wait()

  state = core.VMState.capture_vm_state(M, suspend = False)
  state.save('ducky-snapshot.bin')
  info('VM snapshot save in ducky-snapshot.bin')

  import tabulate

  table_exits = [
    ['Core', 'Exit code']
  ]

  table_inst_caches = [
    ['Core', 'Reads', 'Inserts', 'Hits', 'Misses', 'Prunes']
  ]
  table_data_caches = [
    ['Core', 'Reads', 'Inserts', 'Hits', 'Misses', 'Prunes']
  ]

  def __check_stats(core):
    table_exits.append([str(core), core.exit_code])

    table_inst_caches.append([
      str(core),
      core.instruction_cache.reads,
      core.instruction_cache.inserts,
      core.instruction_cache.hits,
      core.instruction_cache.misses,
      core.instruction_cache.prunes
    ])

    table_data_caches.append([
      str(core),
      core.data_cache.reads,
      core.data_cache.inserts,
      core.data_cache.hits,
      core.data_cache.misses,
      core.data_cache.prunes
    ])

  M.for_each_core(__check_stats)

  info('Exit codes')
  print_table(table_exits)
  info('')
  info('Instruction caches')
  print_table(table_inst_caches)
  info('')
  info('Data caches')
  print_table(table_data_caches)
  info('')

  main_profiler.disable()

  profiler.STORE.save('profile')

  sys.exit(M.exit_code)

if __name__ == '__main__':
  main()

