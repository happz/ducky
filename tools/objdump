#!/usr/bin/python

import ctypes
import optparse
import struct
import sys
import types

import cpu
import irq
import io
import mm
import cpu.instructions
import mm.binary
import util

from mm import UInt8, UInt16, ADDR_FMT, UINT16_FMT, UINT8_FMT, SIZE_FMT
from cpu.errors import CPUException
from util import *

def main():
  parser = optparse.OptionParser()

  parser.add_option('-v', dest = 'verbosity', action = 'count', default = 0, help = 'Verbosity level')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')

  parser.add_option('-d', dest = 'disassemble', default = False, action = 'store_true', help = 'Disassemble TEXT sections')

  options, args = parser.parse_args()

  util.set_verbosity(options.verbosity)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)

  with mm.binary.File(options.file_in, 'r') as f_in:
    f_in.load()

    info()

    f_header = f_in.get_header()
    info('=== File header ===')
    info('  Magic:    0x%X' % f_header.magic)
    info('  Version:  %i' % f_header.version)
    info('  Sections: %i' % f_header.sections)

    info()

    info('=== Sections ===')

    for i in range(0, f_header.sections):
      header, content = f_in.get_section(i)

      info()
      info('* Section #%i' % header.index)
      info('  Name:   %s' % header.get_name())
      info('  Type:   %s' % mm.binary.SECTION_TYPES[header.type])
      flags = [
        'R' if header.flags.readable == 1 else '-',
        'W' if header.flags.writable == 1 else '-',
        'X' if header.flags.executable == 1 else '-'
      ]
      info('  Flags:  %s (0x%X)' % (''.join(flags), ctypes.cast(ctypes.byref(header.flags), ctypes.POINTER(ctypes.c_ubyte)).contents.value))
      info('  Base:   %s' % ADDR_FMT(header.base))
      info('  Size:   %s' % SIZE_FMT(header.size))
      info('  Offset: %s' % ADDR_FMT(header.offset))

      if not options.disassemble:
        continue

      if header.type == mm.binary.SectionTypes.TEXT:
        info()

        csp = UInt16(header.base)
        j = 0
        while j < header.size:
          inst = content[j]
          csp_str = ADDR_FMT(csp.u16)

          csp.u16 += 4
          j += 1

          info('  ', csp_str, cpu.instructions.disassemble_instruction(inst))

      if header.type == mm.binary.SectionTypes.SYMBOLS:
        info()

        j = 0
        while j < header.size:
          entry = content[j]
          j += 1

          _header, _content = f_in.get_section(entry.section)

          info('  ', 'Name:    %s' % entry.get_name())
          info('  ', 'Address: %s' % ADDR_FMT(entry.address))
          info('  ', 'Size:    %s' % SIZE_FMT(entry.size))
          info('  ', 'Section: %i' % entry.section)
          info('  ', 'Type:    %s' % mm.binary.SYMBOL_DATA_TYPES[entry.type])

          symbol_content = None

          if entry.type == mm.binary.SymbolDataTypes.INT:
            symbol_content = UInt16(0)
            symbol_content.u16 = _content[entry.address - _header.base].u8 | (_content[entry.address - _header.base + 1].u8 << 8)
            symbol_content = '%i' % symbol_content.u16

          elif entry.type == mm.binary.SymbolDataTypes.STRING:
            symbol_content = '"' + ''.join(['%s' % chr(c.u8) for c in _content[entry.address - _header.base:entry.address - _header.base + entry.size]]) + '"'

          if symbol_content:
            info('  ', 'Content: %s' % symbol_content)
          info('  ')

if __name__ == '__main__':
  main()

