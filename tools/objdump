#! /usr/bin/env python

import os
import sys

if os.environ.get('DUCKY_IMPORT_DEVEL', 'no') == 'yes':
  sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))

import ctypes
import optparse
import re
import tabulate

import ducky.patch
import ducky.console
import ducky.cpu
import ducky.mm
import ducky.cpu.instructions
import ducky.mm.binary
import ducky.util

from ducky.mm import UInt16, ADDR_FMT, UINT16_FMT, SIZE_FMT, UINT32_FMT
from ducky.util import info, print_table

def show_file_header(f):
  f_header = f.get_header()

  info('=== File header ===')
  info('  Magic:    0x%X', f_header.magic)
  info('  Version:  %i', f_header.version)
  info('  Sections: %i', f_header.sections)
  info('')

def show_sections(f):
  info('=== Sections ===')
  info('')

  f_header = f.get_header()

  table = [
    ['Index', 'Name', 'Type', 'Flags', 'Base', 'Items', 'Size', 'Offset']
  ]

  for i in range(0, f_header.sections):
    header, content = f.get_section(i)

    table.append([
      header.index,
      f.string_table.get_string(header.name),
      ducky.mm.binary.SECTION_TYPES[header.type],
      '%s (0x%02X)' % (''.join(['R' if header.flags.readable == 1 else '-', 'W' if header.flags.writable == 1 else '-', 'X' if header.flags.executable == 1 else '-', 'B' if header.flags.bss == 1 else '-']), ctypes.cast(ctypes.byref(header.flags), ctypes.POINTER(ctypes.c_ubyte)).contents.value),
      ADDR_FMT(header.base),
      header.items,
      SIZE_FMT(header.size),
      SIZE_FMT(header.offset)
    ])

  print_table(table)

  info('')

def show_disassemble(f):
  info('=== Disassemble ==')
  info('')

  f_header = f.get_header()

  for i in range(0, f_header.sections):
    header, content = f.get_section(i)

    if header.type != ducky.mm.binary.SectionTypes.TEXT:
      continue

    info('  Section %s', f.string_table.get_string(header.name))

    csp = UInt16(header.base)
    for inst in content:
      csp_str = ADDR_FMT(csp.u16)
      csp.u16 += 4

      info('  %s (%s) %s', csp_str, UINT32_FMT(inst.overall.u32), ducky.cpu.instructions.disassemble_instruction(inst))

  info('')

def show_symbols(f):
  ascii_replacements = {
    '\n':   '\\n',
    '\r':   '\\r',
    '\x00': '\\0'
  }

  def ascii_replacer(m):
    ascii_replacements[m.group(0)]

  ascii_replace = re.compile('|'.join(ascii_replacements.keys()))

  info('=== Symbols ===')
  info('')

  f_header = f.get_header()

  table = [
    ['Name', 'Section', 'Address', 'Type', 'Size', 'File', 'Line', 'Content']
  ]

  for i in range(0, f_header.sections):
    header, content = f.get_section(i)

    if header.type != ducky.mm.binary.SectionTypes.SYMBOLS:
      continue

    for index, entry in enumerate(content):
      _header, _content = f.get_section(entry.section)

      table_row = [
        f.string_table.get_string(entry.name),
        f.string_table.get_string(_header.name),
        ADDR_FMT(entry.address),
        '%s (%i)' % (ducky.mm.binary.SYMBOL_DATA_TYPES[entry.type], entry.type),
        SIZE_FMT(entry.size),
        f.string_table.get_string(entry.filename),
        entry.lineno
      ]

      symbol_content = ''

      if entry.type == ducky.mm.binary.SymbolDataTypes.INT:
        symbol_content = UInt16(0)
        symbol_content.u16 = _content[entry.address - _header.base].u8 | (_content[entry.address - _header.base + 1].u8 << 8)
        symbol_content = UINT16_FMT(symbol_content.u16)

      elif entry.type == ducky.mm.binary.SymbolDataTypes.ASCII:
        symbol_content = ''.join(['%s' % chr(c.u8) for c in _content[entry.address - _header.base:entry.address - _header.base + entry.size]])

      elif entry.type == ducky.mm.binary.SymbolDataTypes.STRING:
        symbol_content = ''.join(['%s' % chr(c.u8) for c in _content[entry.address - _header.base:entry.address - _header.base + entry.size]])

      if entry.type == ducky.mm.binary.SymbolDataTypes.ASCII or entry.type == ducky.mm.binary.SymbolDataTypes.STRING:
        if len(symbol_content) > 32:
          symbol_content = symbol_content[0:29] + '...'

        symbol_content = '"' + ascii_replace.sub(ascii_replacer, symbol_content) + '"'

      table_row.append(symbol_content)
      table.append(table_row)

  for line in tabulate.tabulate(table, headers = 'firstrow', tablefmt = 'simple', numalign = 'right').split('\n'):
    info(line)

  info('')

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug',       action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')

  parser.add_option('-H', dest = 'header',      default = False, action = 'store_true', help = 'Show file header')
  parser.add_option('-D', dest = 'disassemble', default = False, action = 'store_true', help = 'Disassemble TEXT sections')
  parser.add_option('-s', dest = 'symbols',     default = False, action = 'store_true', help = 'List symbols')
  parser.add_option('-S', dest = 'sections',    default = False, action = 'store_true', help = 'List sections')
  parser.add_option('-a', dest = 'all',         default = False, action = 'store_true', help = 'All of above')

  options, args = parser.parse_args()

  ducky.util.CONSOLE = ducky.console.Console(None, sys.stdin, sys.stdout)
  ducky.util.CONSOLE.set_quiet_mode(not options.debug)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  if options.all:
    options.header = options.disassemble = options.symbols = options.sections = True

  info('Input file: %s', options.file_in)

  with ducky.mm.binary.File(options.file_in, 'r') as f_in:
    f_in.load()

    info('')

    if options.header:
      show_file_header(f_in)

    if options.sections:
      show_sections(f_in)

    if options.symbols:
      show_symbols(f_in)

    if options.disassemble:
      show_disassemble(f_in)

if __name__ == '__main__':
  main()
