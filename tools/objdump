#!/usr/bin/python

import optparse
import struct
import sys
import types

import cpu
import irq
import io
import mm
import cpu.instructions
import mm.binary
import util

from mm import UInt8, UInt16, ADDR_FMT, UINT16_FMT, UINT8_FMT, SIZE_FMT
from cpu.instructions import ins2str
from cpu.errors import CPUException
from util import *

def main():
  parser = optparse.OptionParser()

  parser.add_option('-v', dest = 'verbosity', action = 'count', default = 0, help = 'Verbosity level')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')

  parser.add_option('-d', dest = 'disassemble', default = False, action = 'store_true', help = 'Disassemble TEXT sections')

  options, args = parser.parse_args()

  util.set_verbosity(options.verbosity)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)

  with mm.binary.File(options.file_in, 'r') as f_in:
    f_in.load()

    info()

    f_header = f_in.get_header()
    info('=== File header ===')
    info('  Magic:    0x%X' % f_header.magic)
    info('  Version:  %i' % f_header.version)
    info('  Sections: %i' % f_header.sections)

    info()

    info('=== Sections ===')

    for i in range(0, f_header.sections):
      header, content = f_in.get_section(i)

      info()
      info('* Section #%i' % header.index)
      info('  Type:   %s' % mm.binary.SECTION_TYPES[header.type])
      info('  Flags:  0x%X' % header.flags)
      info('  Base:   %s' % ADDR_FMT(header.base))
      info('  Size:   %s' % SIZE_FMT(header.size))
      info('  Offset: %s' % ADDR_FMT(header.offset))

      if not options.disassemble:
        continue

      if header.type == mm.binary.SectionTypes.TEXT:
        info()

        csp = UInt16(header.base)
        j = 0
        while j < header.size:
          ins = content[j]
          next_cell = content[j + 1] if (j + 1) < header.size else None

          csp_str = ADDR_FMT(csp.u16)

          csp.u16 += 2
          j += 1

          ins, additional_operands = cpu.instructions.disassemble_instruction(ins, next_cell)
          info('  ', csp_str, ins)

          if additional_operands:
            csp.u16 += 2 * additional_operands
            j += additional_operands

      if header.type == mm.binary.SectionTypes.SYMBOLS:
        info()

        j = 0
        while j < header.size:
          entry = content[j]
          j += 1

          _header, _content = f_in.get_section(entry.section)

          info('  ', 'Name:    %s' % entry.get_name())
          info('  ', 'Address: %s' % ADDR_FMT(entry.address))
          info('  ', 'Size:    %s' % SIZE_FMT(entry.size))
          info('  ', 'Section: %i' % entry.section)
          info('  ', 'Type:    %s' % mm.binary.SYMBOL_DATA_TYPES[entry.type])

          if entry.type == mm.binary.SymbolDataTypes.INT:
            symbol_content = UInt16(0)
            symbol_content.u16 = _content[entry.address - _header.base].u8 | (_content[entry.address - _header.base + 1].u8 << 8)
            symbol_content = '%i' % symbol_content.u16

          elif entry.type == mm.binary.SymbolDataTypes.STRING:
            symbol_content = '"' + ''.join(['%s' % chr(c.u8) for c in _content[entry.address - _header.base:entry.address - _header.base + entry.size]]) + '"'

          info('  ', 'Content: %s' % symbol_content)
          info('  ')

if __name__ == '__main__':
  main()

