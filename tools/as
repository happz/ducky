#!/usr/bin/python

import optparse
import os.path
import struct
import sys
import types

import cpu
import irq
import io
import mm
import mm.binary
import cpu.compile
import util

from mm import UInt8, UInt16
from cpu.errors import CPUException

from util import *

def main():
  parser = optparse.OptionParser()

  parser.add_option('-v', dest = 'verbosity', action = 'count', default = 0, help = 'Verbosity level')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-f', dest = 'force', default = False, action = 'store_true', help = 'Force overwrite of the output file')
  parser.add_option('-b', dest = 'base', default = 0, help = 'Base address of code segment')

  options, args = parser.parse_args()

  util.set_verbosity(options.verbosity)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)
  with open(options.file_in, 'r') as f_in:
    buffer = f_in.readlines()

  (csb, cs), (dsb, ds), symbols = cpu.compile.compile_buffer(buffer, csb = UInt16(int(options.base)))

  if os.path.exists(options.file_out) and not options.force:
    error('Output file %s already exists, use -f to force overwrite' % options.file_out)
    sys.exit(1)

  info('Output file: %s' % options.file_out)

  with mm.binary.File(options.file_out, 'w') as f_out:
    debug('Create file header')
    h_file = f_out.create_header()

    debug('Create TEXT section:  base=0x%X, size=0x%X' % (csb.u16, len(cs)))
    h_text = f_out.create_section()
    h_text.type = mm.binary.SectionTypes.TEXT
    h_text.base = csb.u16

    debug('Create DATA section:  base=0x%X, size=0x%X' % (dsb.u16, len(ds)))
    h_data = f_out.create_section()
    h_data.type = mm.binary.SectionTypes.DATA
    h_data.base = dsb.u16

    debug('Create STACK section')
    h_stack = f_out.create_section()
    h_stack.type = mm.binary.SectionTypes.STACK

    debug('Create SYMBOLS section')
    h_symbols = f_out.create_section()
    h_symbols.type = mm.binary.SectionTypes.SYMBOLS

    symbol_entries = []
    for s_name, s_addr, s_size, s_type in symbols:
      entry = mm.binary.SymbolEntry()
      symbol_entries.append(entry)

      entry.set_name(s_name)
      entry.address = s_addr
      entry.size = s_size.u16
      entry.section = h_data.index

      if s_type == 'int':
        entry.type == mm.binary.SymbolDataTypes.INT
      elif s_type == 'char':
        entry.type == mm.binary.SymbolDataTypes.CHAR
      elif s_type == 'string':
        entry.type = mm.binary.SymbolDataTypes.STRING
      else:
        raise CPUException('Unknown symbol data type: %s' % s_type)

    f_out.set_content(h_text, cs)
    f_out.set_content(h_data, ds)
    f_out.set_content(h_symbols, symbol_entries)

    f_out.save()

  info('Source file successfully translated and saved')

if __name__ == '__main__':
  main()

