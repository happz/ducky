#! /usr/bin/env python

import patch

import optparse
import os.path
import struct
import sys
import types

import console
import cpu
import irq
import io
import mm
import mm.binary
import cpu.assemble
import util

from mm import UInt8, UInt16, ADDR_FMT
from cpu.errors import CompilationError

from util import *

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-E', action = 'store_true', dest = 'preprocess', default = False, help = 'Preprocess only')

  parser.add_option('-f', dest = 'force', default = False, action = 'store_true', help = 'Force overwrite of the output file')
  parser.add_option('-b', dest = 'base', default = 0, help = 'Base address of code segment')

  options, args = parser.parse_args()

  util.CONSOLE = console.Console(None, sys.stdin, sys.stdout)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)
  with open(options.file_in, 'r') as f_in:
    buffer = f_in.read()

  buffer = cpu.assemble.preprocess_buffer(buffer)

  if options.preprocess:
    print buffer
    sys.exit(0)

  try:
    sections = cpu.assemble.translate_buffer(buffer, base_address = UInt16(int(options.base)))

  except CompilationError, exc:
    error(str(exc))
    sys.exit(1)

  if os.path.exists(options.file_out) and not options.force:
    error('Output file %s already exists, use -f to force overwrite' % options.file_out)
    sys.exit(1)

  if options.file_out.endswith('.asm'):
    error('Output file has strange extension: %s' % options.file_out)
    sys.exit(1)

  info('Output file: %s' % options.file_out)

  section_name_to_index = {}

  i = 0
  for s_name, section in sections.items():
    if len(section) == 0:
      del sections[s_name]
      continue

    section_name_to_index[s_name] = i
    i += 1

  with mm.binary.File(options.file_out, 'w') as f_out:
    h_file = f_out.create_header()

    section_name_to_index = {}
    for i, s_name in enumerate(sections.keys()):
      section_name_to_index[s_name] = i

    for s_name, section in sections.items():
      h_section = f_out.create_section()
      h_section.type = section.type
      h_section.items = len(section.content)
      h_section.set_name(section.name)
      h_section.base = section.base.u16

      if section.type == mm.binary.SectionTypes.SYMBOLS:
        symbol_entries = []

        for se in section.content:
          entry = mm.binary.SymbolEntry()
          symbol_entries.append(entry)

          entry.set_name(se.name.name)
          entry.address = se.section_ptr.u16
          entry.size = se.size.u16
          entry.section = section_name_to_index[se.section.name]

          entry.type = se.symbol_type

        f_out.set_content(h_section, symbol_entries)

      else:
        if 'r' in section.flags:
          h_section.flags.readable = 1
        if 'w' in section.flags:
          h_section.flags.writable = 1
        if 'x' in section.flags:
          h_section.flags.executable = 1
        if 'b' in section.flags:
          h_section.flags.bss = 1

        f_out.set_content(h_section, section.content)

    f_out.save()

  info('Source file successfully translated and saved')

if __name__ == '__main__':
  main()

