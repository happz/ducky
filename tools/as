#!/usr/bin/python

import optparse
import os.path
import struct
import sys
import types

import cpu
import irq
import io
import mm
import mm.binary
import cpu.assemble
import util

from mm import UInt8, UInt16, ADDR_FMT
from cpu.errors import CPUException

from util import *

def main():
  parser = optparse.OptionParser()

  parser.add_option('-v', dest = 'verbosity', action = 'count', default = 0, help = 'Verbosity level')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-f', dest = 'force', default = False, action = 'store_true', help = 'Force overwrite of the output file')
  parser.add_option('-b', dest = 'base', default = 0, help = 'Base address of code segment')

  options, args = parser.parse_args()

  util.set_verbosity(options.verbosity)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)
  with open(options.file_in, 'r') as f_in:
    buffer = f_in.readlines()

  sections = cpu.assemble.translate_buffer(buffer, base_address = UInt16(int(options.base)))

  if os.path.exists(options.file_out) and not options.force:
    error('Output file %s already exists, use -f to force overwrite' % options.file_out)
    sys.exit(1)

  info('Output file: %s' % options.file_out)

  section_name_to_index = {}

  i = 0
  for s_name, section in sections.items():
    if 'b' in section.flags and len(section) == 0:
      debug('Remove section %s, it\'s empty' % s_name)
      del sections[s_name]
      continue

    section_name_to_index[s_name] = i
    i += 1

  with mm.binary.File(options.file_out, 'w') as f_out:
    debug('Create file header')
    h_file = f_out.create_header()

    section_name_to_index = {}
    for i, s_name in enumerate(sections.keys()):
      section_name_to_index[s_name] = i

    for s_name, section in sections.items():
      debug('Create section %s: base=%s, size=%s' % (section.name, ADDR_FMT(section.base.u16), len(section)))

      h_section = f_out.create_section()
      h_section.type = section.type
      h_section.size = len(section.content)
      h_section.set_name(section.name)
      h_section.base = section.base.u16

      if section.type == mm.binary.SectionTypes.SYMBOLS:
        symbol_entries = []
        for se_name, se_type, se_size, se_section, se_addr in section.content:
          entry = mm.binary.SymbolEntry()
          symbol_entries.append(entry)

          entry.set_name(se_name)
          entry.address = se_addr.u16
          entry.size = se_size.u16
          entry.section = section_name_to_index[se_section]

          if se_type == 'int':
            entry.type == mm.binary.SymbolDataTypes.INT
          elif se_type == 'char':
            entry.type == mm.binary.SymbolDataTypes.CHAR
          elif se_type == 'string':
            entry.type = mm.binary.SymbolDataTypes.STRING
          elif se_type == 'function':
            entry.type = mm.binary.SymbolDataTypes.FUNCTION
          else:
            raise CPUException('Unknown symbol data type: %s' % s_type)

        f_out.set_content(h_section, symbol_entries)

      else:
        if 'r' in section.flags:
          h_section.flags.readable = 1
        if 'w' in section.flags:
          h_section.flags.writable = 1
        if 'x' in section.flags:
          h_section.flags.executable = 1
        if 'b' in section.flags:
          h_section.flags.bss = 1

        f_out.set_content(h_section, section.content)

    f_out.save()

  info('Source file successfully translated and saved')

if __name__ == '__main__':
  main()

