#! /usr/bin/env python

import patch

import optparse
import os.path
import sys

import console
import cpu
import mm
import mm.binary
import cpu.assemble
import util

from mm import UInt16
from cpu.errors import CompilationError
from util import info, error, exception, debug

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-E', action = 'store_true', dest = 'preprocess', default = False, help = 'Preprocess only')

  parser.add_option('-f', dest = 'force', default = False, action = 'store_true', help = 'Force overwrite of the output file')
  parser.add_option('-b', dest = 'base', default = 0, help = 'Base address of code segment')
  parser.add_option('-m', '--mmap', dest = 'mmap', action = 'store_true', default = False, help = 'Create mmap\'able sections')

  options, args = parser.parse_args()

  util.CONSOLE = console.Console(None, sys.stdin, sys.stdout)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  info('Input file: %s' % options.file_in)
  with open(options.file_in, 'r') as f_in:
    buffer = f_in.read()

  if options.preprocess:
    buffer = cpu.assemble.preprocess_buffer(buffer)
    print buffer
    sys.exit(0)

  try:
    sections = cpu.assemble.translate_buffer(buffer, base_address = UInt16(int(options.base)), mmapable_sections = options.mmap, filename = options.file_in)

  except cpu.assemble.AssemblerError, exc:
    exception(exc)
    sys.exit(1)

  except CompilationError, exc:
    error(str(exc))
    sys.exit(1)

  if os.path.exists(options.file_out) and not options.force:
    error('Output file %s already exists, use -f to force overwrite' % options.file_out)
    sys.exit(1)

  if options.file_out.endswith('.asm'):
    error('Output file has strange extension: %s' % options.file_out)
    sys.exit(1)

  info('Output file: %s' % options.file_out)

  section_name_to_index = {}

  i = 0
  for s_name, section in sections.items():
    if section.type == mm.binary.SectionTypes.SYMBOLS:
      continue

    if 'b' in section.flags and section.size > 0:
      continue

    if section.size > 0:
      continue

    debug('Removing section %s because it is empty', s_name)
    del sections[s_name]

    section_name_to_index[s_name] = i
    i += 1

  with mm.binary.File(options.file_out, 'w') as f_out:
    h_file = f_out.create_header()
    h_file.flags.mmapable = 1 if options.mmap else 0

    filenames = {}

    section_name_to_index = {}
    for i, s_name in enumerate(sections.keys()):
      section_name_to_index[s_name] = i

    for s_name, section in sections.items():
      h_section = f_out.create_section()
      h_section.type = section.type
      h_section.items = section.items
      h_section.size = section.size
      h_section.name = f_out.string_table.put_string(section.name)
      h_section.base = section.base.u16

      if section.type == mm.binary.SectionTypes.SYMBOLS:
        symbol_entries = []

        for se in section.content:
          entry = mm.binary.SymbolEntry()
          symbol_entries.append(entry)

          entry.name = f_out.string_table.put_string(se.name.name)
          entry.address = se.section_ptr.u16
          entry.size = se.size.u16
          entry.section = section_name_to_index[se.section.name]

          if se.filename:
            if se.filename not in filenames:
              filenames[se.filename] = f_out.string_table.put_string(se.filename)
            entry.filename = filenames[se.filename]

          if se.lineno:
            entry.lineno = se.lineno

          entry.type = se.symbol_type

        f_out.set_content(h_section, symbol_entries)
        h_section.size = cpu.assemble.sizeof(mm.binary.SymbolEntry()) * len(symbol_entries)

      else:
        if 'r' in section.flags:
          h_section.flags.readable = 1
        if 'w' in section.flags:
          h_section.flags.writable = 1
        if 'x' in section.flags:
          h_section.flags.executable = 1
        if 'b' in section.flags:
          h_section.flags.bss = 1

        f_out.set_content(h_section, section.content)

    h_section = f_out.create_section()
    h_section.type = mm.binary.SectionTypes.STRINGS
    h_section.name = f_out.string_table.put_string('.strings')

    f_out.save()

  info('Source file successfully translated and saved')

if __name__ == '__main__':
  main()
