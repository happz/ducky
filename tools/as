#! /usr/bin/env python

import os
import sys

if os.environ.get('DUCKY_IMPORT_DEVEL', 'no') == 'yes':
  sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))

import optparse

import ducky.patch
import ducky.console
import ducky.cpu
import ducky.mm
import ducky.mm.binary
import ducky.cpu.assemble
import ducky.util

from ducky.mm import UInt16
from ducky.util import error, exception

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-D', dest = 'defines', action = 'append', default = [], help = 'Define variable')

  parser.add_option('-E', action = 'store_true', dest = 'preprocess', default = False, help = 'Preprocess only')

  parser.add_option('-f', dest = 'force', default = False, action = 'store_true', help = 'Force overwrite of the output file')
  parser.add_option('-b', dest = 'base', default = 0, help = 'Base address of code segment')
  parser.add_option('-m', '--mmap', dest = 'mmap', action = 'store_true', default = False, help = 'Create mmap\'able sections')

  options, args = parser.parse_args()

  ducky.util.CONSOLE = ducky.console.Console(None, sys.stdin, sys.stdout)
  ducky.util.CONSOLE.set_quiet_mode(not options.debug)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  with open(options.file_in, 'r') as f_in:
    buffer = f_in.read()

  if options.preprocess:
    buffer = ducky.cpu.assemble.preprocess_buffer(buffer)
    print buffer
    sys.exit(0)

  try:
    sections = ducky.cpu.assemble.translate_buffer(buffer, base_address = UInt16(int(options.base)), mmapable_sections = options.mmap, filename = options.file_in, defines = options.defines)

  except ducky.cpu.assemble.AssemblerError, exc:
    exception(exc)
    sys.exit(1)

  if os.path.exists(options.file_out) and not options.force:
    error('Output file %s already exists, use -f to force overwrite' % options.file_out)
    sys.exit(1)

  if options.file_out.endswith('.asm'):
    error('Output file has strange extension: %s' % options.file_out)
    sys.exit(1)

  section_name_to_index = {}

  i = 0
  for s_name, section in sections.items():
    if section.type == ducky.mm.binary.SectionTypes.SYMBOLS:
      continue

    if 'b' in section.flags and section.data_size > 0:
      continue

    if section.data_size > 0:
      continue

    del sections[s_name]

    section_name_to_index[s_name] = i
    i += 1

  with ducky.mm.binary.File(options.file_out, 'w') as f_out:
    h_file = f_out.create_header()
    h_file.flags.mmapable = 1 if options.mmap else 0

    filenames = {}

    section_name_to_index = {}
    for i, s_name in enumerate(sections.keys()):
      section_name_to_index[s_name] = i

    for s_name, section in sections.items():
      h_section = f_out.create_section()
      h_section.type = section.type
      h_section.items = section.items
      h_section.data_size = section.data_size
      h_section.file_size = section.file_size
      h_section.name = f_out.string_table.put_string(section.name)
      h_section.base = section.base.u16

      if section.type == ducky.mm.binary.SectionTypes.SYMBOLS:
        symbol_entries = []

        for se in section.content:
          entry = ducky.mm.binary.SymbolEntry()
          symbol_entries.append(entry)

          entry.name = f_out.string_table.put_string(se.name.name)
          entry.address = se.section_ptr.u16
          entry.size = se.size.u16
          entry.section = section_name_to_index[se.section.name]

          if se.filename:
            if se.filename not in filenames:
              filenames[se.filename] = f_out.string_table.put_string(se.filename)
            entry.filename = filenames[se.filename]

          if se.lineno:
            entry.lineno = se.lineno

          entry.type = se.symbol_type

        f_out.set_content(h_section, symbol_entries)
        h_section.data_size = h_section.file_size = ducky.cpu.assemble.sizeof(ducky.mm.binary.SymbolEntry()) * len(symbol_entries)

      else:
        if 'r' in section.flags:
          h_section.flags.readable = 1
        if 'w' in section.flags:
          h_section.flags.writable = 1
        if 'x' in section.flags:
          h_section.flags.executable = 1
        if 'b' in section.flags:
          h_section.flags.bss = 1
        if 'm' in section.flags:
          h_section.flags.mmapable = 1

        f_out.set_content(h_section, section.content)

    h_section = f_out.create_section()
    h_section.type = ducky.mm.binary.SectionTypes.STRINGS
    h_section.name = f_out.string_table.put_string('.strings')

    f_out.save()

if __name__ == '__main__':
  main()
