#! /usr/bin/env python

import patch

import collections
import optparse
import os
import pprint
import re
import shutil
import subprocess
import sys
import tempfile
import types

from llvmlite import binding as llvm
from llvmlite import ir as lc

import console
import cpu.registers
import util

from cpu.assemble import Buffer
from util import *

class CompilationError(Exception):
  pass

RE_ID   = r'(?:[%@][-a-zA-Z$._0-9][-a-zA-Z$._0-9]*)'
RE_SUBTYPE = '(?:(?:[iu]\d+\**)|(?:%struct.[\w_]+))'
RE_TYPE = r'(?:(?:\({pattern_subtype}(?:, {pattern_subtype})*\))|(?:void)|(?:{pattern_subtype})|(?:\[\d+ x {pattern_subtype}\]))\**'.format(pattern_subtype = RE_SUBTYPE)
RE_TYPE = r'{pattern_type}(?: {pattern_type})*'.format(pattern_type = RE_TYPE)

def RE(p):
  return re.compile(p.format(pattern_id = RE_ID, pattern_subtype = RE_SUBTYPE, pattern_type = RE_TYPE), re.MULTILINE)

RE_MODULE_ID  = RE(r'^; ModuleID = \'(?P<name>.*?)\'$')
RE_DEFINE     = RE(r'^define(?: (?P<internal>internal))?(?: (?P<cc>fastcc))?(?: (?P<rflags>signext|zeroext))? (?P<rtype>{pattern_type}) (?P<name>{pattern_id})\((?P<args>.*?)\) #0 {{$')
RE_FN_END     = RE(r'^}}$')
RE_FUNC_ATTRS = RE(r'^; Function Attrs:\s+(?P<attrs>[\w ]+)$')
RE_GLOBAL_VAR = RE(r'^(?P<name>{pattern_id}) =(?: (?P<linkage>private|internal))?(?: (?P<unnamed_addr>unnamed_addr))?(?: (?P<constant>constant|global)) (?P<type>{pattern_type}) (?P<content>.*?)(?:, align \d+)?$')
RE_LABEL      = RE(r'^(?:(?P<label>[a-zA-Z0-9-_]+):)|(?:; \<label\>:(?P<name>\d+)).*$')
RE_STRUCT     = RE(r'^\s*(?P<name>{pattern_id}) = type {{ (?P<members>{pattern_type}(?:, {pattern_type})*) }}$')

#def debug(*args):
# pass

def name_is_id(name):
  return name[0] in ('@', '%')

class PregLRUCache(collections.OrderedDict):
  def touch(self, preg):
    preg = self.pop(preg.name)
    self[preg.name] = preg

class GlobalVariable(object):
  def __init__(self, module, name, type, content, linkage = None, constant = None):
    self.module = module
    self.name = name
    self.type = type
    self.content = content
    self.linkage = linkage
    self.constant = constant

    self.symbol = None
    self.vreg = None

class Structure(object):
  def __init__(self, name, members):
    self.name = name
    self.members = members

    self.size = sum([m.size for m in members])

class Type(object):
  base_sizes = {
    'i32':  2,
    'i64':  2,
    'i8':   1,
    '*':    2,
    'void': 0,
    'i1':   2,
    'i16':  2,
    'u16':  2
  }

  STRUCTS = {}

  @staticmethod
  def type(raw):
    if raw.startswith('%struct.'):
      return StructureType(raw)

    if raw.startswith('['):
      return ArrayType(raw)

    return Type(raw)

  def __init__(self, raw):
    self.raw = raw

    raw = raw.split('*')

    self.base = raw[0]
    self.depth = len(raw)

    self.subtype = None
    self.repeat = None

    if self.is_ptr():
      self.size = self.base_sizes['*']
      return

    if self.base in self.base_sizes:
      self.size = self.base_sizes[self.base]
      return

  def __repr__(self):
    return '<type: %s, base=%s, depth=%s, size=%s>' % (self.raw, self.base, self.depth, self.size)

  def __eq__(self, t):
    return self.raw == t.raw

  def __ne__(self, t):
    return self.raw != t.raw

  def is_ptr(self):
    return self.depth > 1

  def is_byte(self):
    return not self.is_ptr() and self.size == 1

  def ptr_to(self):
    return Type.type(self.raw + '*')

  def deref(self):
    if self.depth == 1:
      return self

    return Type.type(self.raw[:-1])

class ArrayType(Type):
  def __init__(self, raw):
    super(ArrayType, self).__init__(raw)

    cnt, type = self.base.split('x')

    self.subtype = Type.type(type.strip()[:-1])
    self.repeat = int(cnt.strip()[1:])

    if not self.is_ptr():
      self.size = int(self.repeat) * self.subtype.size

class StructureType(Type):
  def __init__(self, raw):
    super(StructureType, self).__init__(raw)

    self.struct = Type.STRUCTS[self.base]

    if not self.is_ptr():
      self.size = self.struct.size

class Argument(object):
  def __init__(self, type, name, flags):
    self.type = type
    self.name = name
    self.flags = flags

  def __repr__(self):
    return '<argument: type=%s, name=%s, flags=%s>' % (self.type, self.name, self.flags)

  @staticmethod
  def construct_arg(s):
    arg = [a.strip() for a in s.strip().split()]

    return Argument(Type.type(arg[0]), arg[-1], arg[1:-1])

  @staticmethod
  def construct_args(s, fn = None):
    arg_pattern = RE(r'(?P<type>{pattern_type})(?: (?P<flags>signext|zeroext))? (?P<value>(?:\d+)|(?:{pattern_id}|(?:getelementptr(?: (?P<inbounds>inbounds))? \((?P<gep_type>\[\d+ x \w+\]\*+) (?P<gep_src>{pattern_id}), (?P<gep_indices>.*?)\))))')

    args = collections.OrderedDict()

    for matches in arg_pattern.finditer(s):
      matches = matches.groupdict()

      if matches['gep_src'] is None:
        name = matches['value']

        args[name] = Argument(Type.type(matches['type']), name, matches['flags'])

      else:
        name = matches['gep_src']
        args[name] = (matches['gep_src'], Type.type(matches['gep_type']), GETELEMENTPTR.process_indices(matches['gep_indices']))

    #i32 256
    #i8 signext %9
    #i8* getelementptr inbounds ([14 x i8]* @.str, i64 0, i64 0)
    #i8* getelementptr(?: (?P<gep_inbounds>inbounds))? \((?P<gep_type>\[\d+ x \w+\]\*+) (?P<gep_src>@\.?\w+), (?P<indices>.*?)\)

    return args


class Module(object):
  def __init__(self):
    self.name = None

    self.attrs = {}

    self.vregs = collections.OrderedDict()

    self.globals = []
    self.functions = []

    self.asm_prolog = None

  def add_global_var(self, var):
    self.globals.append(var)

    var.symbol = var.name[1:] # strip of '@' at the beginning

    var.vreg = self.vregs[var.name] = VirtualRegister(var.name, var.type, global_symbol = var.symbol)

  def add_function(self, fn):
    self.functions.append(fn)

    fn.vreg = self.vregs[fn.name] = FunctionVirtualRegister(fn.name, fn.rtype, fn = fn)

  def asm(self, *additions):
    self.asm_prolog += additions

  def generate_asm(self):
    self.asm_prolog = []

    ASM = self.asm

    ASM('; module %s' % self.name)

    ASM('.include "defs.asm"')

    for var in self.globals:
      ASM(
        '; global var: name=%s, type=%s, content=%s' % (var.vreg.name, var.vreg.type, var.content),
        ';   space is of type %s' % var.vreg.type.deref()
      )

      if var.constant == 'constant':
        ASM('.section .rodata')
      else:
        ASM('.data')

      space_type = var.vreg.type.deref()

      if space_type.subtype is not None and space_type.repeat is not None:
        space_subtype = space_type.subtype
        if not space_subtype.is_ptr() and space_subtype.base == 'i8':
          ASM(
            '.type %s, ascii' % var.symbol,
            '.ascii "%s"' % var.content[2:-1]
          )

        continue

      matches = GETELEMENTPTR.arg_pattern.match(var.content)
      if matches:
        matches = matches.groupdict()

        indices = GETELEMENTPTR.process_indices(matches['indices'])
        offset = GETELEMENTPTR.compute_offset(Type.type(matches['type']), indices)

        if offset == 0:
          ASM(
            '.type %s, int' % var.symbol,
            '.int &%s' % matches['src'][1:]
          )

    for fn in self.functions:
      fn.generate_asm()

  def complete_asm(self):
    asm = []

    asm += self.asm_prolog

    for fn in self.functions:
      asm += fn.asm_prolog

      for block in fn.blocks.itervalues():
        asm += block.asm_insts

    return asm


class Function(object):
  def __init__(self, module):
    self.module = module

    self.vreg = None

    self.name = None
    self.symbol = None
    self.args = collections.OrderedDict()
    self.attrs = {}

    self.rtype = None

    self.vregs = collections.OrderedDict()
    self.pregs = collections.OrderedDict()
    self.preg_lru = PregLRUCache()

    for i in range(0, len(PhysicalRegister.REGISTERS)):
      preg = PhysicalRegister(self, i)
      self.pregs[preg.name] = preg
      self.preg_lru[preg.name] = preg

    self.fp_offset = 0

    self.asm_prolog = []

    self.blocks = collections.OrderedDict()
    self.block = None

  def get_vreg(self, name):
    if name in self.vregs:
      return self.vregs[name]

    if name in self.module.vregs:
      return self.module.vregs[name]

    if name in self.module.vregs:
      return self.module.vregs[fn.name]

    raise KeyError(name)

  def close(self):
    pass

  def alloc_local(self, vreg):
    self.fp_offset = vreg.local_offset = align(2, self.fp_offset + vreg.type.deref().size)

  def alloc_spill(self, vreg):
    self.fp_offset = vreg.spill_offset = align(2, self.fp_offset + vreg.type.deref().size)

  def prolog_asm(self, *additions):
    self.asm_prolog += additions

  def epilog_asm(self, block, *additions):
    block.asm(*additions)

  def generate_epilog(self, block):
    self.epilog_asm(block, '; epilog')

    if self.name == '@main':
      return

    for vreg in self.callee_saved_vregs:
      if vreg.preg is not None:
        continue

      vreg.acquire_preg(block, arg = vreg.first_preg.id, fn = self)
      vreg.unspill(block)

    if self.fp_offset != 0:
      self.epilog_asm(block, 'add sp, %s ; unroll alloca\'s' % self.fp_offset)

    else:
      self.epilog_asm(block, '; no unroll needed')

  def generate_asm(self):
    self.asm_prolog = []
    self.asm_epilog = []

    self.prolog_asm(
      '.text',
      '%s:' % self.symbol
    )

    self.prolog_asm('; release global pregs')
    # release all pregs acquired by global vars - all should be clean anyway
    for vreg in self.module.vregs.itervalues():
      assert vreg.preg is None or vreg.preg.dirty is False
      vreg.release_preg()

    self.arguments_pregs = [self.pregs['r%i' % i] for i in range(0, len(self.args))]
    self.callee_saved_vregs = []

    if self.name != '@main':
      self.prolog_asm('; acquire pregs for callee-saved registers')
      for preg in [preg for preg in self.pregs.itervalues() if preg not in self.arguments_pregs]:
        name = '__dcc_callee_saved_preg_%s__' % preg.name
        vreg = self.vregs[name] = VirtualRegister(name, Type.type('u16'), fn = self)
        vreg.acquire_preg(None, arg = preg.id, fn = self)
        vreg.first_preg = vreg.preg
        vreg.preg.dirty = True
        self.preg_lru.touch(vreg.preg)
        self.callee_saved_vregs.append(vreg)

    # args will have pregs touched after callee-saved pregs => any later allocations will unspill callee-saved pregs first

    self.prolog_asm('; acquire pregs for arguments')
    for i, arg in enumerate(self.args.values()):
      vreg = self.vregs[arg.name] = VirtualRegister(arg.name, arg.type, fn = self)
      vreg.acquire_preg(None, arg = i, fn = self)
      vreg.preg.dirty = True
      self.preg_lru.touch(vreg.preg)
      self.arguments_pregs.append(vreg.preg)

    for block in self.blocks.itervalues():
      block.generate_asm()

    if self.fp_offset != 0:
      self.prolog_asm('sub sp, %s ; space for locals' % self.fp_offset)

class VirtualRegister(object):
  def __init__(self, name, type, fn = None, global_symbol = None):
    self.fn = fn

    self.name = name
    self.type = type
    self.preg = None

    self.local_offset = None
    self.spill_offset = None

    self.global_symbol = global_symbol

  def __repr__(self):
    return 'VReg: name=%s, type=%s, preg=%s, dirty=%s, spill=%s, local=%s, global=%s' % (self.name, self.type, self.preg.name if self.preg is not None else None, self.preg.dirty if self.preg else None, self.spill_offset, self.local_offset, self.global_symbol)

  def has_preg(self):
    return self.preg is not None

  def release_preg(self, block = None):
    """
    Release physical register. Save its content into memory if necessary.
    """

    if self.preg is None:
      return

    debug('vreg.release_preg: name=%s, preg=%s' % (self.name, self.preg.name))

    if self.preg.dirty is True:
      self.spill(block)

    self.preg.vreg = None
    self.preg = None

  def acquire_preg(self, block, fn = None, nospill = None, arg = None):
    """
    Acquire physical register to hold value of this virtual register.
    """

    nospill = nospill or []

    if self.preg is not None:
      return

    if arg is not None:
      if fn is None:
        fn = block.fn

      arg = 'r%i' % arg
      preg = fn.pregs[arg]

      if preg.vreg is not None:
        preg.vreg.release_preg(block)

      self.preg = preg
      preg.vreg = self
      preg.used = True
      return

    fn = block.fn

    # 1st pass - find empty register
    registers = [pr for pr in fn.preg_lru.itervalues() if pr.vreg is None]
    if len(registers):
      self.preg = registers.pop(0)
      fn.preg_lru.touch(self.preg)
      self.preg.vreg = self
      self.preg.dirty = False
      self.preg.used = True
      block.asm('; acquire preg: found in pass #1: name=%s, preg=%s' % (self.name, self.preg.name))
      return

    # 2nd pass - used btu clean
    registers = [pr for pr in fn.preg_lru.itervalues() if pr not in nospill and pr.dirty is not True]
    if len(registers):
      self.preg = registers.pop(0)
      fn.preg_lru.touch(self.preg)
      debug('vreg.acquire_preg: pass #2, previous owner %s' % self.preg.vreg)
      self.preg.vreg.release_preg(block)
      self.preg.vreg = self
      self.preg.dirty = False
      self.preg.used = True
      block.asm('; acquire preg: found in pass #2: name=%s, preg=%s' % (self.name, self.preg.name))
      return

    # 3rd pass - used and dirty
    registers = [pr for pr in fn.preg_lru.itervalues() if pr not in nospill]
    if len(registers):
      self.preg = registers.pop(0)
      fn.preg_lru.touch(self.preg)
      debug('vreg.acquire_preg: pass #3, previous owner %s' % self.preg.vreg)
      self.preg.vreg.release_preg(block)
      self.preg.vreg = self
      self.preg.used = True
      block.asm('; acquire preg: found in pass #3: name=%s, preg=%s' % (self.name, self.preg.name))
      return

    raise CompilationError('Unable to allocate register for %s' % self.name)

  def spill(self, block):
    assert self.has_preg()

    if self.preg.dirty is not True:
      return

    if block is None:
      warn('vreg.spill: undefined block, ignore')
      return

    if self.spill_offset is None:
      block.fn.alloc_spill(self)

    if self.type.deref().is_byte():
      block.asm('stb fp[-%s], %s ; spill %s' % (self.spill_offset, self.preg.name, self.name))
    else:
      block.asm('stw fp[-%s], %s ; spill %s' % (self.spill_offset, self.preg.name, self.name))

    self.preg.dirty = False

  def unspill(self, block, preg = None, nospill = None):
    if self.spill_offset is None:
      block.fn.alloc_spill(self)

    assert self.spill_offset is not None

    if preg is None:
      self.acquire_preg(block, nospill = nospill)
      preg = self.preg

    if self.type.deref().is_byte():
      block.asm('lb %s, fp[-%s] ; unspill %s' % (preg.name, self.spill_offset, self.name))
    else:
      block.asm('lw %s, fp[-%s] ; unspill %s' % (preg.name, self.spill_offset, self.name))

    self.preg.dirty = False

  def save_to(self, block, vreg_dst):
    if self.preg is None:
      self.unspill(block)

    if not vreg_dst.has_preg():
      vreg_dst.unspill(block, nospill = [self.preg])

    if self.type.is_byte():
      block.asm('stb %s, %s' % (vreg_dst.preg.name, self.preg.name))
    else:
      block.asm('stw %s, %s' % (vreg_dst.preg.name, self.preg.name))

  def load_from(self, block, vreg_src):
    if not self.has_preg():
      self.acquire_preg(block, nospill = [vreg_src.preg])

    if vreg_src.global_symbol is not None:
      addr_operand = '&%s' % vreg_src.global_symbol
      block.asm(
        'li %s, &%s' % (self.preg.name, vreg_src.global_symbol),
        'lw %s, %s' % (self.preg.name, self.preg.name)
      )

    else:
      if not vreg_src.has_preg():
        vreg_src.unspill(block, nospill = [self.preg])

      if self.type.is_byte():
        block.asm('lb %s, %s' % (self.preg.name, vreg_src.preg.name))
      else:
        block.asm('lw %s, %s' % (self.preg.name, vreg_src.preg.name))

    self.preg.dirty = True

  def copy_value_to_preg(self, block, preg):
    assert preg is not None

    if self.global_symbol is not None:
      block.asm(
        'li %s, &%s' % (preg.name, self.global_symbol)
      )

    else:
      if self.has_preg():
        block.asm('mov %s, %s' % (preg.name, self.preg.name))

      else:
        if self.spill_offset is None:
          block.fn.alloc_spill(self)

        block.asm('lw %s, fp[-%s]' % (preg.name, self.spill_offset))

    preg.dirty = True

  def copy_value_from(self, block, vreg_src):
    self.acquire_preg(block, nospill = [vreg_src.preg])

    if vreg_src.has_preg():
      block.asm('mov %s, %s' % (self.preg.name, vreg_src.preg.name))

    else:
      assert vreg_src.spill_offset is not None
      block.asm('lw %s, fp[-%s]' % (self.preg.name, vreg_src.spill_offset))

    self.preg.dirty = True


class FunctionVirtualRegister(VirtualRegister):
  def __init__(self, *args, **kwargs):
    super(FunctionVirtualRegister, self).__init__(*args, **kwargs)

  def spill(self, block):
    self.preg.dirty = False

  def unspill(self, block, preg = None, nospill = None):
    if preg is None:
      self.acquire_preg(block, nospill = nospill)
      preg = self.preg

    block.asm('li %s, &%s' % (preg.name, self.fn.name))
    self.preg.dirty = False


class PhysicalRegister(object):
  REGISTERS = ['r%i' % i for i in range(0, cpu.registers.Registers.REGISTER_SPECIAL)]

  def __init__(self, fn, id):
    self.id = id
    self.fn = fn
    self.name = self.REGISTERS[id]

    self.used = False

    self.vreg = None
    self.dirty = False

  def __repr__(self):
    return '<preg: name=%s>' % self.name

class Block(object):
  def __init__(self, fn, name):
    self.fn = fn
    self.name = name

    self.next = None

    self.label = '.__%s_%s' % (fn.symbol, name)

    self.ir_insts = []
    self.asm_insts = []

  def close(self):
    pass

  def flush_vregs(self, globals_only = False):
    dirty_locals = []
    if not globals_only:
      dirty_locals = [vreg for vreg in self.fn.vregs.itervalues() if vreg.preg is not None and vreg.preg.dirty is True]

    dirty_globals = [vreg for vreg in self.fn.module.vregs.itervalues() if vreg.preg is not None and vreg.preg.dirty is True]

    for vreg in dirty_locals + dirty_globals:
      vreg.spill(self)

  def asm(self, *additions):
    self.asm_insts += additions

  def generate_asm(self):
    self.asm_insts = []

    ASM = self.asm

    ASM(
      '; block %s' % self.name,
      '%s:' % self.label
    )

    insts = self.ir_insts[:]

    while insts:
      inst = insts.pop(0)

      debug('IR:')
      debug('  ' + repr(inst))
      debug('  ' + inst.line)

      ASM('; ----------------')
      ASM(';  ' + repr(inst))
      ASM(';  ' + inst.line)

      thread_jump = False

      if (len(insts) == 0 and (isinstance(inst, BR_LABEL) or isinstance(inst, RET))) or (len(insts) == 1 and isinstance(inst, ICMP) and isinstance(insts[0], BR_COND)):
        thread_jump = len(insts) == 0 and isinstance(inst, BR_LABEL) and self.next is not None and ('%' + self.next.name) == inst.dst
        if thread_jump:
          ASM('; threading jump, no need to flush vregs')

        elif isinstance(inst, RET):
          ASM('; ret, flush only global vregs')
          self.flush_vregs(globals_only = True)

        else:
          # other terminating instruction is RET but do we need to save stack vars to stack, when we unroll before ret anyway?
          ASM('; flush dirty after block')
          self.flush_vregs()

      if isinstance(inst, ICMP):
        next_inst = insts.pop(0)
        if isinstance(next_inst, BR_COND):
          inst.generate_asm(next_inst)
        else:
          insts.insert(0, next_inst)
          inst.generate_asm(None)

      elif not thread_jump:
        inst.generate_asm()

      else:
        ASM('; threading jump')

    ASM('; block %s ends' % self.name)

class Instruction(object):
  def __init__(self, block, line):
    self.block = block
    self.line = line

  def generate_asm(self, *args):
    return None

class BinaryArithmeticInstructionMeta(type):
  def __init__(cls, name, bases, dct):
    cls.pattern = RE(r'^\s*(?P<dst>{pattern_id}) = ' + cls.ir_inst_mnemonic + r'(?: (?P<flag>nsw|nuw))? (?P<type>{pattern_type}) (?P<lvalue>{pattern_id}|-?\d+), (?P<rvalue>{pattern_id}|-?\d+)$')

class BinaryArithmeticInstruction(Instruction):
  def __init__(self, block, line, dst = None, type = None, lvalue = None, rvalue = None, flag = None):
    super(BinaryArithmeticInstruction, self).__init__(block, line)

    self.dst = dst
    self.type = Type.type(type)
    self.lvalue = lvalue
    self.rvalue = rvalue
    self.flag = flag

  def __repr__(self):
    return '%s: dst=%s, type=%s, lvalue=%s, rvalue=%s, flag=%s' % (self.ir_inst_mnemonic, self.dst, self.type, self.lvalue, self.rvalue, self.flag)

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type, fn = F)
    vreg_dst.acquire_preg(B)

    if name_is_id(self.lvalue):
      vreg_lvalue = F.get_vreg(self.lvalue)
      vreg_dst.copy_value_from(B, vreg_lvalue)

    else:
      ASM('li %s, %s' % (vreg_dst.preg.name, self.lvalue))

    if name_is_id(self.rvalue):
      vreg_rvalue = F.get_vreg(self.rvalue)
      vreg_rvalue.unspill(B, nospill = [vreg_dst.preg])

      ASM('%s %s, %s' % (self.asm_inst_mnemonic, vreg_dst.preg.name, vreg_rvalue.preg.name))

    else:
      ASM('%s %s, %s' % (self.asm_inst_mnemonic, vreg_dst.preg.name, self.rvalue))

class TypecastInstructionMeta(type):
  def __init__(cls, name, bases, dct):
    cls.pattern = RE(r'^\s*(?P<dst>{pattern_id}) = ' + cls.ir_inst_mnemonic + r' (?P<src_type>{pattern_type}) (?P<src>{pattern_id}) to (?P<dst_type>{pattern_type})$')

class TypecastInstruction(Instruction):
  def __init__(self, block, line, dst = None, dst_type = None, src = None, src_type = None):
    super(TypecastInstruction, self).__init__(block, line)

    self.dst = dst
    self.src_type = Type.type(src_type)
    self.src = src
    self.dst_type = Type.type(dst_type)

  def __repr__(self):
    return '%s: dst=%s dst_type=%s, src=%s, src_type=%s' % (self.ir_inst_mnemonic, self.dst, self.dst_type, self.src, self.src_type)

  def generate_typecast(self, vreg_dst):
    if self.src_type.is_byte():
      self.block.asm('; typecasting from byte to longer - hic sunt leones')

  def generate_asm(self):
    B = self.block
    F = B.fn

    vreg_src = F.get_vreg(self.src)

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.dst_type, fn = F)
    vreg_dst.copy_value_from(B, vreg_src)

    self.generate_typecast(vreg_dst)

class CALL(Instruction):
  pattern = RE(r'^\s*(?:(?P<dst>{pattern_id}) = )?call(?: (?P<cc>fastcc))?(?: (?P<signext>signext))? (?P<type>{pattern_type}) (?P<name>{pattern_id})\((?P<args>.*?)\)$')

  def __init__(self, block, line, dst, type, name, args):
    super(CALL, self).__init__(block, line)

    self.dst = dst
    self.type = type
    self.name = name

    self.symbol = self.name[1:] # skip @

    self.args = Argument.construct_args(args, fn = self.block.fn)

  def __repr__(self):
    return 'call: dst=%s, type=%s, name=%s, args=%s' % (self.dst, self.type, self.name, self.args)

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    pregs = []

    for i, arg in enumerate(self.args.values()):
      preg = F.pregs['r%i' % i]
      pregs.append(preg)

      if preg.vreg is not None:
        preg.vreg.release_preg(B)

      if isinstance(arg, Argument):
        ASM('; %s %s' % (arg.type, arg.name))

        if arg.name[0] in ('@', '%'):
          vreg = F.get_vreg(arg.name)
          vreg.copy_value_to_preg(B, preg)

        else:
          ASM('li %s, %s' % (preg.name, arg.name))

      else:
        ASM('; %s' % str(arg))

        vreg = F.get_vreg(arg[0])
        vreg.copy_value_to_preg(B, preg)

        GETELEMENTPTR.compute_offset(arg[1], arg[2], preg = vreg.preg, block = B, nospill = pregs + [vreg.preg])

    ASM('call &%s' % self.symbol)

    if self.dst is not None:
      vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type)
      vreg_dst.acquire_preg(B, arg = 0)
      debug('vreg_dst: %s', vreg_dst)

class CALL_ASM(Instruction):
  pattern = RE(r'^\s*call void asm sideeffect "(?P<asm>.*?)", .*?$')

  def __init__(self, block, line, asm):
    super(CALL_ASM, self).__init__(block, line)

    self.asm = asm

  def __repr__(self):
    return 'call: asm=%s' % self.asm

  def generate_asm(self):
    self.block.asm(
      '; %s' % repr(self),
      self.asm
    )

class ALLOCA(Instruction):
  pattern = RE(r'^\s*(?P<dst>{pattern_id}) = alloca (?P<type>{pattern_type}), align (?P<align>\d+)$')

  def __init__(self, block, line, dst, type, align):
    super(ALLOCA, self).__init__(block, line)

    self.dst = dst
    self.type = type
    self.align = align

  def __repr__(self):
    return 'alloca: dst=%s, type=%s, align=%s' % (self.dst, self.type, self.align)

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    vreg = F.vregs[self.dst] = VirtualRegister(self.dst, self.type.ptr_to(), fn = F)
    F.alloc_local(vreg)

    vreg.acquire_preg(B)

    ASM(
      'mov %s, fp' % vreg.preg.name,
      'sub %s, %s' % (vreg.preg.name, vreg.local_offset)
    )

    vreg.preg.dirty = True

class SWITCH(Instruction):
  pattern_start = RE(r'^\s*switch {pattern_type} (?P<src>{pattern_id}), label (?P<default_dst>{pattern_id}) \[$')
  pattern_branch = RE(r'^\s*{pattern_type} (?P<value>\d+), label (?P<dst>{pattern_id})')
  pattern_end = RE(r'^\s*\]$')

  def __init__(self, block, line, src, default_dst):
    super(SWITCH, self).__init__(block, line)

    self.src = src
    self.default_dst = default_dst

    self.branches = []

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    vreg_src = F.get_vreg(self.src)

    vreg_src.acquire_preg(B)

    for value, label in self.branches:
      ASM(
        'cmp %s, %s' % (vreg_src.preg.name, value),
        'be &.__%s_%s' % (F.name, label)
      )

    ASM('j &.__%s_%s' % (F.name, self.default_dst[1:]))

class SDIV(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'sdiv'
  asm_inst_mnemonic = 'div'

class UDIV(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'udiv'
  asm_inst_mnemonic = 'div'

class SREM(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'srem'
  asm_inst_mnemonic = 'mod'

class UREM(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'urem'
  asm_inst_mnemonic = 'mod'

class MUL(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'mul'
  asm_inst_mnemonic = 'mul'

class AND(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'and'
  asm_inst_mnemonic = 'and'

class ADD(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'add'
  asm_inst_mnemonic = 'add'

class SUB(BinaryArithmeticInstruction):
  __metaclass__ = BinaryArithmeticInstructionMeta

  ir_inst_mnemonic = 'sub'
  asm_inst_mnemonic = 'sub'

class RET(Instruction):
  pattern = RE(r'^\s*ret (?P<rtype>{pattern_type})(?: (?P<ret>%?\w+))?$')

  def __init__(self, block, line, rtype, rvalue):
    super(RET, self).__init__(block, line)

    self.rtype = rtype
    self.rvalue = rvalue

  def __repr__(self):
    return 'ret: rtype=%s, rvalue=%s' % (self.rtype, self.rvalue)

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    F.generate_epilog(B)

    if self.rtype.base == 'void':
      ASM('ret')
      return

    if self.rvalue[0] in ('@', '%'):
      vreg_ret = F.get_vreg(self.rvalue)

      preg = F.pregs['r0']
      if preg.vreg is not None and preg.vreg is not vreg_ret:
        preg.vreg.release_preg(B)

      vreg_ret.copy_value_to_preg(B, preg)

    else:
      ASM('li r0, %s' % self.rvalue)

    if F.name == '@main':
      ASM('int 0')

    else:
      ASM('ret')

class SEXT(TypecastInstruction):
  __metaclass__ = TypecastInstructionMeta

  ir_inst_mnemonic = 'sext'

class ZEXT(TypecastInstruction):
  __metaclass__ = TypecastInstructionMeta

  ir_inst_mnemonic = 'zext'

class BITCAST(TypecastInstruction):
  __metaclass__ = TypecastInstructionMeta

  ir_inst_mnemonic = 'bitcast'

class TRUNC(TypecastInstruction):
  __metaclass__ = TypecastInstructionMeta

  ir_inst_mnemonic = 'trunc'

  def generate_typecast(self, vreg_dst):
    if self.dst_type.is_byte() and self.src_type.size > 1:
      self.block.asm('and %s, 0xFF' % vreg_dst.preg.name)

class SELECT(Instruction):
  pattern = RE(r'^\s*(?P<dst>{pattern_id}) = select i1 (?P<cond>{pattern_id}), (?P<type_true>{pattern_type}) (?P<true>{pattern_id}|\d+), (?P<type_false>{pattern_type}) (?P<false>{pattern_id}|\d+)$')

  def __init__(self, block, line, dst = None, cond = None, type_true = None, true = None, type_false = None, false = None):
    super(SELECT, self).__init__(block, line)

    self.dst = dst
    self.cond = cond
    self.type_true = Type.type(type_true)
    self.true = true
    self.type_false = Type.type(type_false)
    self.false = false

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    label_false = '&.__%s_select_%s_false' % (F.name, self.dst)
    label_end   = '&.__%s_select_%s_end' % (F.name, self.dst)

    vreg_cond = F.get_vreg(self.cond)
    vreg_cond.unspill(B)

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type_true, fn = F)
    vreg_dst.acquire_preg(B, nospill = [vreg_cond.preg])

    ASM(
      'cmp %s, 0' % vreg_cond.preg.name,
      'bne &.__%s_select_%s' % (F.name, self.dst),
    )

    if name_is_id(self.true):
      vreg_src = F.get_vreg(self.true)
      vreg_src.unspill(B, nospill = [vreg_dst.preg])
      vreg_dst.copy_value_from(B, vreg_src)
      vreg_src.release_preg(B)

    else:
      ASM('li %s, %s' % (vreg_dst.preg.name, self.true))

    ASM(
      'j &%s' % label_end,
      '%s:' % label_false
    )

    if name_is_id(self.false):
      vreg_src = F.get_vreg(self.false)
      vreg_src.unspill(B, nospill = [vreg_dst.preg])
      vreg_dst.copy_value_from(B, vreg_src)
      vreg_src.release_preg(B)

    else:
      ASM('li %s, %s' % (vreg_dst.preg.name, self.false))

    ASM('%s:' % label_end)

class ICMP(Instruction):
  pattern = RE(r'^\s*(?P<dst>{pattern_id}) = icmp (?P<op>\w+) (?P<type>{pattern_type}) (?P<lvalue>{pattern_id}), (?P<rvalue>%?\w+)$')

  def __init__(self, block, line, dst, op, type, lvalue, rvalue):
    super(ICMP, self).__init__(block, line)

    self.dst = dst
    self.op = op
    self.type = type
    self.lvalue = lvalue
    self.rvalue = rvalue

  def __repr__(self):
    return 'icmp: dst=%s, op=%s, type=%s, lvalue=%s, rvalue=%s' % (self.dst, self.op, self.type, self.lvalue, self.rvalue)

  def generate_asm(self, br_cond):
    B = self.block
    F = B.fn
    ASM = B.asm

    ASM(
      '; %s' % repr(self),
      '; %s' % repr(br_cond)
    )

    B.flush_vregs()

    vreg_lvalue = F.get_vreg(self.lvalue)
    vreg_lvalue.acquire_preg(B)

    if br_cond is None:
      vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type, fn = F)
      vreg_dst.acquire_preg(B)

    if self.rvalue[0] in ('@', '%'):
      vreg_rvalue = F.get_vreg(self.rvalue)
      vreg_rvalue.acquire_preg(B)

      ASM('cmp %s, %s' % (vreg_lvalue.preg.name, vreg_rvalue.preg.name))

    else:
      ASM('cmp %s, %s' % (vreg_lvalue.preg.name, self.rvalue))

    if br_cond is None:
      ASM('; store cmp result into %s' % vreg_dst.preg.name)

    else:
      if self.op == 'ne':
        ASM(
          'bne &.__%s_%s' % (F.symbol, br_cond.true[1:]),
          'j &.__%s_%s' % (F.symbol, br_cond.false[1:])
        )

      elif self.op == 'eq':
        ASM(
          'be &.__%s_%s' % (F.symbol, br_cond.true[1:]),
          'j &.__%s_%s' % (F.symbol, br_cond.false[1:])
        )

      else:
        warn('unhandled ICMP op: op=%s' % self.op)

class BR_COND(Instruction):
  pattern = RE(r'^\s*br (?P<type>{pattern_type}) (?P<src>{pattern_id}), label (?P<true>{pattern_id}), label (?P<false>{pattern_id})$')

  def __init__(self, block, line, type, src, true, false):
    super(BR_COND, self).__init__(block, line)

    self.type = type
    self.src = src
    self.true = true
    self.false = false

class BR_LABEL(Instruction):
  pattern = RE(r'^\s*br label (?P<dst>{pattern_id})$')

  def __init__(self, block, line, dst):
    super(BR_LABEL, self).__init__(block, line)

    self.dst = dst

  def generate_asm(self):
    self.block.asm('j &.__%s_%s' % (self.block.fn.symbol, self.dst[1:]))

class GETELEMENTPTR(Instruction):
  pattern = RE(r'^\s*(?P<dst>{pattern_id}) = getelementptr(?: (?P<inbounds>inbounds))? (?P<type>{pattern_type}) (?P<src>{pattern_id}), (?P<indices>.*?)$')
  arg_pattern = RE(r'getelementptr(?: (?P<inbounds>inbounds))? \((?P<type>{pattern_type}) (?P<src>{pattern_id}), (?P<indices>.*?)\)')

  def __init__(self, block, line, dst, type, src, indices):
    super(GETELEMENTPTR, self).__init__(block, line)

    self.dst = dst
    self.type = type
    self.src = src

    self.indices = GETELEMENTPTR.process_indices(indices)

  def __repr__(self):
    return 'getelementptr: dst=%s, type=%s, src=%s, indices=%s' % (self.dst, self.type, self.src, self.indices)

  @staticmethod
  def process_indices(indices):
    ret = []

    for index in indices.split(','):
      index_type, index_value = index.strip().split(' ')

      index_value = index_value.strip()
      if index_value.startswith('%'):
        pass

      else:
        index_value = int(index_value)

      ret.append((Type.type(index_type.strip()), index_value))

    return ret

  @staticmethod
  def compute_offset(type, indices, preg = None, block = None, nospill = None):
    nospill = nospill or []

    indices = list(indices)

    debug('getelementptr: type=%s, indices=%s', type, indices)

    if any([isinstance(index[1], types.StringType) for index in indices]):
      assert preg is not None
      assert block is not None

      preg_tmp = None

      pregs = [pr for pr in block.fn.pregs.itervalues() if pr not in nospill]
      preg_tmp = pregs.pop(0)
      if preg_tmp.vreg is not None:
        preg_tmp.vreg.release_preg(block)

      nospill.append(preg_tmp)

      offset = None
    else:
      offset = 0

    # walk throught the first pointer
    index_type, index_value = indices.pop()
    type = type.deref()

    debug('    index=%s, type=%s', index_value, type)

    if isinstance(index_value, types.StringType):
      vreg_index = block.fn.get_vreg(index_value)
      vreg_index.acquire_preg(block, nospill = nospill)
      vreg_index.copy_value_to_preg(block, preg_tmp)
      block.asm(
        'mul %s, %s' % (preg_tmp.name, type.size),
        'add %s, %s' % (preg, preg_tmp.name)
      )

    else:
      offset += type.size * index_value
      debug('    offset=%s', offset)

    # walk through the members
    for index_type, index_value in indices:
      debug('    index=%s, type=%s', index_value, type)

      # arrays
      if type.subtype is not None:
        type = type.subtype
        offset += type.size * index_value

      debug('    offset=%s', offset)

    return offset

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    vreg_src = F.get_vreg(self.src)

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type)
    vreg_dst.copy_value_from(B, vreg_src)

    GETELEMENTPTR.compute_offset(self.type, self.indices, preg = vreg_dst.preg.name, block = B, nospill = [vreg_dst.preg])

class LOAD(Instruction):
  pattern =  RE(r'^\s*(?P<dst>{pattern_id}) = load (?P<src_type>{pattern_type}) (?P<src>{pattern_id})(?:, align (?P<align>\d+))?$')

  def __init__(self, block, line, dst, src_type, src, align):
    super(LOAD, self).__init__(block, line)

    self.dst = dst
    self.src_type = src_type
    self.src = src
    self.align = align

  def __repr__(self):
    return 'load: dst=%s, src_type=%s, src=%s, align=%s' % (self.dst, self.src_type, self.src, self.align)

  def generate_asm(self):
    B = self.block
    F = B.fn

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.src_type.deref())
    debug('vreg_dst: %s', vreg_dst)

    vreg_src = F.get_vreg(self.src)
    debug('vreg_src: %s', vreg_src)

    #if vreg_dst.type != vreg_src.type.deref():
    #  warn('Different types in LOAD: src=%s, dst=%s' % (vreg_src.type, vreg_dst.type))
    #  warn('  %s' % self.line)

    vreg_dst.load_from(B, vreg_src)

class STORE(Instruction):
  pattern = RE(r'^\s*store (?P<type_value>{pattern_type}) (?P<value>(?:{pattern_id})|(?:-?\d+)), (?P<type_dst>{pattern_type}) (?P<dst>{pattern_id})(?:, align \w+)?$')

  def __init__(self, block, line, type_value, value, type_dst, dst):
    super(STORE, self).__init__(block, line)

    self.type_value = type_value
    self.value = value
    self.type_dst = type_dst
    self.dst = dst

  def __repr__(self):
    return 'store: type_value=%s, value=%s, type_dst=%s, dst=%s' % (self.type_value, self.value, self.type_dst, self.dst)

  def generate_asm(self):
    B = self.block
    F = B.fn

    vreg_dst = F.get_vreg(self.dst)
    vreg_dst.acquire_preg(B)
    debug('vreg_dst: %s', vreg_dst)

    if self.value[0] in ('@', '%'):
      vreg_src = F.get_vreg(self.value)
      debug('vreg_src: %s', vreg_src)

      #if vreg_dst.type != vreg_src.type.ptr_to():
      #  warn('Different types in STORE: %s vs %s' % (vreg_src.type, vreg_dst.type))
      #  warn('  %s' % self.line)

      vreg_src.save_to(B, vreg_dst)

    else:
      vreg_tmp = VirtualRegister('tmp', self.type_value)
      vreg_tmp.acquire_preg(B, nospill = [vreg_dst.preg])

      B.asm('li %s, %s' % (vreg_tmp.preg.name, self.value))
      vreg_tmp.save_to(B, vreg_dst)

    vreg_dst.preg.dirty = True

class PHI(Instruction):
  pattern = RE(r'^\s*(?P<dst>{pattern_id}) = phi (?P<type>{pattern_type}) (?P<predecessors>\[ {pattern_id}, {pattern_id} \](?:, \[\])*)')
  pattern_predecessor = RE(r'\[ (?P<src>{pattern_id}), (?P<label>{pattern_id}) \]')

  def __init__(self, block, line, dst, type, *predecessors):
    super(PHI, self).__init__(block, line)

    self.dst = dst
    self.type = type
    self.predecessors = predecessors

  def generate_asm(self):
    B = self.block
    F = B.fn
    ASM = B.asm

    vreg_dst = F.vregs[self.dst] = VirtualRegister(self.dst, self.type)
    vreg_dst.acquire_preg(B)
    vreg_dst.unspill(B)

def compile_module(mod_ir):
  M = Module()
  F = None
  B = None

  buff = Buffer('<unknown>', mod_ir.split('\n'))

  def create_function():
    f = Function(M)
    return f

  def create_block(name):
    b = Block(F, name)

    if B is not None:
      B.next = b

    F.blocks[name] = b
    F.block = b
    return b

  while buff.has_lines():
    line = buff.get_line()

    if line is None:
      break

    if not line.strip():
      continue

    msg_prefix = 'pass #1: %s:%s: ' % (os.path.split(buff.filename)[1], buff.lineno)

    debug(msg_prefix + 'line=%s', line)

    matches = RE_MODULE_ID.match(line)
    if matches:
      M.name = matches.groupdict()['name']
      continue

    matches = RE_FUNC_ATTRS.match(line)
    if matches:
      if F is None:
        F = create_function()

      for attr in matches.groupdict()['attrs'].split(' '):
        debug(msg_prefix + 'setting function attr: name=%s, attr=%s', F.name, attr)
        F.attrs[attr] = True

      continue

    matches = RE_DEFINE.match(line)
    if matches:
      matches = matches.groupdict()

      debug(msg_prefix + 'defining new function')

      if F is None:
        F = create_function()

      F.name = matches['name']
      F.symbol = F.name[1:] # skip @

      B = create_block('0')

      if matches['args']:
        F.args = Argument.construct_args(matches['args'])

      F.rtype = Type.type(matches['rtype'])

      M.add_function(F)

      debug(msg_prefix + 'defined function: name=%s, rtype=%s', F.name, F.rtype)
      continue

    matches = RE_FN_END.match(line)
    if matches:
      F.close()
      debug(msg_prefix + 'fn closed: name=%s', F.name)
      F = None
      B = None
      continue

    matches = RE_GLOBAL_VAR.match(line)
    if matches:
      matches = matches.groupdict()

      var = GlobalVariable(M, matches['name'], Type.type(matches['type']).ptr_to(), matches['content'], linkage = matches['linkage'], constant = matches['content'])
      M.add_global_var(var)
      continue

    matches = ALLOCA.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(ALLOCA(B, line, matches['dst'], Type.type(matches['type']), matches['align']))
      continue

    matches = LOAD.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(LOAD(B, line, matches['dst'], Type.type(matches['src_type']), matches['src'], matches['align']))
      continue

    matches = STORE.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(STORE(B, line, Type.type(matches['type_value']), matches['value'], Type.type(matches['type_dst']), matches['dst']))
      continue

    matches = ICMP.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(ICMP(B, line, matches['dst'], matches['op'], Type.type(matches['type']), matches['lvalue'], matches['rvalue']))
      continue

    matches = BR_COND.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(BR_COND(B, line, Type.type(matches['type']), matches['src'], matches['true'], matches['false']))
      continue

    matches = BR_LABEL.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(BR_LABEL(B, line, matches['dst']))
      continue

    matches = RET.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(RET(B, line, Type.type(matches['rtype']), matches['ret']))
      debug(msg_prefix + 'RET')
      continue

    matches = RE_LABEL.match(line)
    if matches:
      matches = matches.groupdict()
      name = matches['name'] if matches['name'] else matches['label']
      B = create_block(name)
      continue

    matches = UDIV.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(UDIV(B, line, **matches))
      continue

    matches = SREM.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(SREM(B, line, matches['dst'], Type.type(matches['type']), matches['lvalue'], matches['rvalue']))
      continue

    matches = UREM.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(UREM(B, line, **matches))
      continue

    matches = MUL.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(MUL(B, line, **matches))
      continue

    matches = GETELEMENTPTR.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(GETELEMENTPTR(B, line, matches['dst'], Type.type(matches['type']), matches['src'], matches['indices']))
      continue

    matches = CALL.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(CALL(B, line, matches['dst'], Type.type(matches['type']), matches['name'], matches['args']))
      continue

    matches = CALL_ASM.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(CALL_ASM(B, line, matches['asm']))
      continue

    matches = SEXT.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(SEXT(B, line, **matches))
      continue

    matches = ZEXT.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(ZEXT(B, line, **matches))
      continue

    matches = AND.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(AND(B, line, **matches))
      continue

    matches = ADD.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(ADD(B, line, **matches))
      continue

    matches = SUB.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(SUB(B, line, **matches))
      continue

    matches = BITCAST.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(BITCAST(B, line, **matches))
      continue

    matches = TRUNC.pattern.match(line)
    if matches:
      matches = matches.groupdict()
      B.ir_insts.append(TRUNC(B, line, **matches))
      continue

    matches = SWITCH.pattern_start.match(line)
    if matches:
      matches = matches.groupdict()

      inst = SWITCH(B, line, matches['src'], matches['default_dst'])
      B.ir_insts.append(inst)

      line = buff.get_line()

      while True:
        if line is None or not line.strip():
          continue

        matches = SWITCH.pattern_branch.match(line)
        if not matches:
          buff.put_line(line)
          break

        matches = matches.groupdict()
        inst.branches.append((matches['value'], matches['dst']))
        line = buff.get_line()

      continue

    matches = SWITCH.pattern_end.match(line)
    if matches:
      continue

    matches = SELECT.pattern.match(line)
    if matches:
      B.ir_insts.append(SELECT(B, line, **matches.groupdict()))
      continue

    matches = RE_STRUCT.match(line)
    if matches:
      matches = matches.groupdict()

      struct = Structure(matches['name'], [Type.type(t.strip()) for t in matches['members'].split(',')])
      Type.STRUCTS[struct.name] = struct
      continue

    matches = PHI.pattern.match(line)
    if matches:
      matches = matches.groupdict()

      predecessors = []

      for p_matches in PHI.pattern_predecessor.finditer(matches['predecessors']):
        p_matches = p_matches.groupdict()
        predecessors.append((p_matches['src'], p_matches['label']))

      B.ir_insts.append(PHI(B, line, matches['dst'], Type.type(matches['type']), *predecessors))
      continue

    warn('Unhandled line: %s',line)

  M.generate_asm()
  asm = M.complete_asm()

  return '\n'.join(['%s%s' % ('' if line.endswith(':') else '  ', line) for line in asm])

def file_src_to_preprocess(file_in, file_out):
  try:
    subprocess.check_output('clang -E -o %s %s' % (file_out, file_in), shell = True)

  except subprocess.CalledProcessError, e:
    raise CompilationError('clang subprocess failed')

def file_src_to_ir(file_in, file_out, options):
  if options.opt_one:
    opt_passes = [
      '-reassociate',
      '-sccp',
      '-sink',
      '-constprop',
      '-dce',
      '-deadargelim',
      '-die',
      '-dse',
      '-globalopt',
      '-instcombine',
      '-jump-threading'
    ]

  elif options.opt_zero:
    opt_passes = [
      '-jump-threading',
      '-die',
      '-dse'
    ]

  else:
    opt_passes = []

  try:
    subprocess.check_output('clang -O0 -S -emit-llvm -o - %s | opt %s - | llvm-dis -o %s' % (file_in, ' '.join(opt_passes), file_out), shell = True)

  except subprocess.CalledProcessError, e:
    raise CompilationError('clang subprocess failed')

def file_ir_to_asm(file_in, file_out):
  with open(file_in, 'rb') as f_in:
    mod_ir = f_in.read()

  with open(file_out, 'wb') as f_out:
    f_out.write(compile_module(mod_ir))

def file_asm_to_bin(file_in, file_out):
  try:
    subprocess.check_output('/data/virtualenv/ducky/ducky/tools/as -i %s -o %s -f' % (file_in, file_out), shell = True)

  except subprocess.CalledProcessError, e:
    raise CompilationError('das subprocess failed')

def compile_file(file_in, file_out, options):
  def __copy_or_print(__file_in, __file_out):
    if __file_out == '-':
      with open(__file_in, 'r') as f:
        print f.read()

    else:
      shutil.copy(__file_in, __file_out)

    os.unlink(__file_in)

  if options.emit_preprocess:
    tmp_file = tempfile.NamedTemporaryFile(delete = False)
    tmp_file.close()

    file_src_to_preprocess(file_in, tmp_file.name)
    __copy_or_print(tmp_file.name, file_out)
    return

  ir_file = tempfile.NamedTemporaryFile(delete = False)
  ir_file.close()

  file_src_to_ir(file_in, ir_file.name, options)

  if options.emit_llvm:
    __copy_or_print(ir_file.name, file_out)
    return

  asm_file = tempfile.NamedTemporaryFile(delete = False)
  asm_file.close()

  file_ir_to_asm(ir_file.name, asm_file.name)
  os.unlink(ir_file.name)

  if options.emit_asm:
    __copy_or_print(asm_file.name, file_out)
    return

  file_asm_to_bin(asm_file.name, file_out)
  os.unlink(asm_file.name)

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')
  parser.add_option('-o', dest = 'file_out', default = None, help = 'Output file')

  parser.add_option('-E', '--emit-preprocess', dest = 'emit_preprocess', action = 'store_true', default = False)
  parser.add_option('-R', '--emit-llvm', dest = 'emit_llvm', action = 'store_true', default = False)
  parser.add_option('-S', '--emit-asm', dest = 'emit_asm', action = 'store_true', default = False)

  parser.add_option('--O0', dest = 'opt_zero', action = 'store_true', default = True)
  parser.add_option('--O1', dest = 'opt_one', action = 'store_true', default = False)

  options, args = parser.parse_args()

  util.CONSOLE = console.Console(None, sys.stdin, sys.stdout)

  if not options.file_in or (options.emit_llvm is not True and not options.file_out):
    parser.print_help()
    sys.exit(1)

  llvm.initialize()

  compile_file(options.file_in, options.file_out, options)

if __name__ == '__main__':
  main()
