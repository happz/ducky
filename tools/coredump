#! /usr/bin/env python

import patch

import optparse
import string
import sys

import console
import core
import mm
import mm.binary
import util

from mm import ADDR_FMT, UINT16_FMT, UINT8_FMT, PAGE_SIZE
from cpu.registers import Flags, Registers, REGISTER_NAMES
from util import info, print_table

def show_header(state):
  info('=== Coredump header ===')
  info('  Magic:        %s', UINT16_FMT(state.magic))
  info('  Version:      %s', state.version)
  info('')
  info('  # of CPUs:      %i', state.nr_cpus)
  info('  # of CPU cores: %i', state.nr_cores)
  info('  # of binaries:  %i', state.binaries)
  info('')

def show_binaries(state):
  info('=== Binaries ===')

  mc_index = 0

  for bs in state.binary_states:
    info('  Path: %s', state.string_table.get_string(bs.path))
    info('  CS: %s DS: %s', UINT8_FMT(bs.cs), UINT8_FMT(bs.ds))
    info('')

    table = [
      ['Section', 'Address', 'Size', 'Flags', 'First page', 'Last page']
    ]

    for rs in state.memory_region_states[mc_index:mc_index + bs.memory_regions]:
      table.append([state.string_table.get_string(rs.name), ADDR_FMT(rs.address), rs.size, rs.flags, rs.pages_start, rs.pages_start + rs.pages_cnt - 1])

    mc_index += bs.memory_regions

    print_table(table)
    info('')

def show_cores(state):
  info('=== Cores ===')

  def __reg(name):
    return UINT16_FMT(getattr(cs, name))

  def __flag(mask):
    return (cs.flags & mask) != 0

  for cs in state.core_states:
    info('Core #%i:#%i', cs.cpuid, cs.coreid)

    for i in range(0, Registers.REGISTER_SPECIAL, 4):
      regs = [(i + j) for j in range(0, 4) if (i + j) < Registers.REGISTER_SPECIAL]
      s = ['reg%02i=%s' % (reg, __reg(REGISTER_NAMES[reg])) for reg in regs]
      info('  %s', ' '.join(s))

    info('  cs=%s    ds=%s', __reg('cs'), __reg('ds'))
    info('  fp=%s    sp=%s    ip=%s', __reg('fp'), __reg('sp'), __reg('ip'))
    info('  priv=%i, hwint=%i, e=%i, z=%i, o=%i, s=%i', __flag(Flags.PRIVILEGED), __flag(Flags.HWINT), __flag(Flags.EQUAL), __flag(Flags.ZERO), __flag(Flags.OVERFLOW), __flag(Flags.SIGNED))
    info('  keep_running=%s, idle=%s, exit=%i', cs.keep_running, cs.idle, cs.exit_code)

    info('')

def show_memory(state):
  info('=== Memory ===')

  info('  Size:          %s', state.mm_state.size)
  info('  IRQ table:     %s', ADDR_FMT(state.mm_state.irq_table_address))
  info('  Int table:     %s', ADDR_FMT(state.mm_state.int_table_address))
  info('  # of segments: %s', state.mm_state.segments)
  info('  # of pages:    %s', state.mm_state.pages)
  info('')

def show_stack(state):
  info('=== Stack ===')

  stacks = [pg for pg in state.mm_page_states if pg.stack == 1]

  sps = {}
  for cs in state.core_states:
    sps[mm.segment_addr_to_addr(cs.ds, cs.sp)] = '#%i:#%i' % (cs.cpuid, cs.coreid)

  for pg in stacks:
    pg_address = pg.index * PAGE_SIZE
    pg_segment = mm.addr_to_segment(pg_address)

    info('=== Page %s - %s %s ===', pg.index, UINT8_FMT(pg_segment), ADDR_FMT(pg_address))

    for ri in range(0, 16):
      row = []
      for ci in range(0, 8):
        offset = PAGE_SIZE - 2 - (ci * 16 + ri) * 2
        segment_offset = pg_address + offset

        v = pg.content[offset] | (pg.content[offset + 1] << 8)
        row.append((sps.get(segment_offset, None), v))

      info('  ' + '  '.join(['%s %s' % (' ' if sp is None else '*', console.WHITE(UINT16_FMT(value)) if value != 0 else console.GREEN(UINT16_FMT(value))) for sp, value in row]))

    info('')

def show_segments(state):
  info('=== Memory segments ===')

  for s in state.mm_segment_states:
    info('  Segment: %s', UINT8_FMT(s.index))

    for bs in state.binary_states:
      if s.index == bs.cs:
        info('    CS of %s', state.string_table.get_string(bs.path))
      if s.index == bs.ds:
        info('    DS of %s', state.string_table.get_string(bs.path))

  info('')

def show_pages(state):
  info('=== Memory pages ===')

  for pg in sorted(state.mm_page_states, key = lambda x: x.index):
    pg_addr = pg.index * PAGE_SIZE
    pg_segment = mm.addr_to_segment(pg_addr)

    for bs in state.binary_states:
      if pg_segment == bs.cs:
        break
      if pg_segment == bs.ds:
        break

    info('  Page #%i (segment %s)', pg.index, UINT8_FMT(pg_segment))
    info('    Flags: %s%s%s%s', 'r' if pg.read == 1 else '-', 'w' if pg.write == 1 else '-', 'x' if pg.execute == 1 else '-', 'd' if pg.dirty == 1 else '-')

    CPR = 32

    for i in range(0, 256 / CPR):
      s = []
      t = []

      for b in pg.content[CPR * i:CPR * (i + 1)]:
        c = '%02X' % b
        s.append(console.GREEN(c) if b == 0 else console.WHITE(c))

        c = chr(b)
        if c in string.printable[0:-5]:
          c = '%%' if c == '%' else (' ' + c)
          t.append(c)

        elif b == 10:
          t.append('\\n')

        elif b == 13:
          t.append('\\r')

        else:
          t.append('  ')

      info('    ' + ADDR_FMT(pg_addr + i * CPR) + ': ' + ' '.join(s))
      info('              ' + ' '.join(t))

      row_symbols = []
      for j in range(pg_addr + i * CPR, pg_addr + i * CPR + CPR):
        if j not in bs.symbols:
          continue

        row_symbols.append((j - (pg_addr + i * CPR)) * 3 * ' ' + '^' + ', '.join(bs.symbols[j]))

      for symbol in row_symbols:
        info('              ' + symbol)

    info('')

def load_binary_symbols(state, bs):
  bs.raw_binary = mm.binary.File(state.string_table.get_string(bs.path), 'r')
  bs.raw_binary.load()

  bs.symbols = {}
  for i in range(0, bs.raw_binary.get_header().sections):
    s_header, s_content = bs.raw_binary.get_section(i)

    if s_header.type != mm.binary.SectionTypes.SYMBOLS:
      continue

    for entry in s_content:
      _header, _content = bs.raw_binary.get_section(entry.section)

      segment = bs.cs if _header.type == mm.binary.SectionTypes.TEXT else bs.ds

      symbol_name = bs.raw_binary.string_table.get_string(entry.name)
      symbol_address = mm.segment_addr_to_addr(segment, entry.address)

      if symbol_address not in bs.symbols:
        bs.symbols[symbol_address] = []
      bs.symbols[symbol_address].append(symbol_name)

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')

  parser.add_option('-H',         dest = 'header',   default = False, action = 'store_true', help = 'Show file header')
  parser.add_option('-C',         dest = 'cores',    default = False, action = 'store_true', help = 'Show cores')
  parser.add_option('-M',         dest = 'memory',   default = False, action = 'store_true', help = 'Show memory')
  parser.add_option('--segments', dest = 'segments', default = False, action = 'store_true', help = 'Show segments')
  parser.add_option('--pages',    dest = 'pages',    default = False, action = 'store_true', help = 'Show pages')
  parser.add_option('-b',         dest = 'binaries', default = False, action = 'store_true', help = 'Show binaries')
  parser.add_option('-s',         dest = 'stack',    default = False, action = 'store_true', help = 'Show stack content')
  parser.add_option('-a',         dest = 'all',      default = False, action = 'store_true', help = 'All of above')

  options, args = parser.parse_args()

  util.CONSOLE = console.Console(None, sys.stdin, sys.stdout)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  if options.all:
    options.header = options.cores = options.memory = options.segments = options.pages = options.binaries = options.stack = True

  info('Input file: %s', options.file_in)

  with core.CoreDumpFile(options.file_in, 'r') as f_in:
    state = f_in.load()

    for bs in state.binary_states:
      load_binary_symbols(state, bs)

    info('')

    if options.header:
      show_header(state)

    if options.binaries:
      show_binaries(state)

    if options.cores:
      show_cores(state)

    if options.memory:
      show_memory(state)

    if options.segments:
      show_segments(state)

    if options.stack:
      show_stack(state)

    if options.pages:
      show_pages(state)

if __name__ == '__main__':
  main()
