#! /usr/bin/env python

import os
import sys

if os.environ.get('DUCKY_IMPORT_DEVEL', 'no') == 'yes':
  sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))

import optparse
import string

import ducky.patch
import ducky.console
import ducky.mm
import ducky.mm.binary
import ducky.snapshot
import ducky.util

from ducky.mm import ADDR_FMT, UINT16_FMT, UINT8_FMT, PAGE_SIZE
from ducky.cpu.registers import Flags, Registers
from ducky.util import info, print_table

def show_header(state):
  state = state.get_child('machine')

  info('=== Coredump header ===')
  info('  # of CPUs:      %i', state.nr_cpus)
  info('  # of CPU cores: %i', state.nr_cores)
  info('  # of binaries:  %i', len(state.get_binary_states()))
  info('')

def show_binaries(state):
  info('=== Binaries ===')

  for bs in state.get_child('machine').get_binary_states():
    info('Path: %s', bs.path)
    info('CS: %s DS: %s', UINT8_FMT(bs.cs), UINT8_FMT(bs.ds))
    info('')

    table = [
      ['Section', 'Address', 'Size', 'Flags', 'First page', 'Last page']
    ]

    for rs in bs.get_children().itervalues():
      table.append([rs.name, ADDR_FMT(rs.address), rs.size, rs.flags, rs.pages_start, rs.pages_start + rs.pages_cnt - 1])

    print_table(table)
    info('')

def show_cores(state):
  info('=== Cores ===')

  def __reg(index):
    return UINT16_FMT(cs.registers[index])

  def __flag(mask):
    return (cs.registers[Registers.FLAGS] & mask) != 0

  for cs in state.get_child('machine').get_core_states():
    info('Core #%i:#%i', cs.cpuid, cs.coreid)

    for i in range(0, Registers.REGISTER_SPECIAL, 4):
      regs = [(i + j) for j in range(0, 4) if (i + j) < Registers.REGISTER_SPECIAL]
      s = ['reg%02i=%s' % (reg, __reg(reg)) for reg in regs]
      info('  %s', ' '.join(s))

    info('  cs=%s    ds=%s', __reg(Registers.CS), __reg(Registers.DS))
    info('  fp=%s    sp=%s    ip=%s', __reg(Registers.FP), __reg(Registers.SP), __reg(Registers.IP))
    info('  priv=%i, hwint=%i, e=%i, z=%i, o=%i, s=%i', __flag(Flags.PRIVILEGED), __flag(Flags.HWINT), __flag(Flags.EQUAL), __flag(Flags.ZERO), __flag(Flags.OVERFLOW), __flag(Flags.SIGNED))
    info('  alive=%s, running=%s, idle=%s, exit=%i', cs.alive, cs.running, cs.idle, cs.exit_code)

    info('')

def show_memory(state):
  info('=== Memory ===')

  state = state.get_child('machine').get_child('memory')

  info('  Size:          %s', state.size)
  info('  IRQ table:     %s', ADDR_FMT(state.irq_table_address))
  info('  Int table:     %s', ADDR_FMT(state.int_table_address))
  info('  # of segments: %s', len(state.segments))
  info('  # of pages:    %s', len(state.get_page_states()))
  info('')

def show_stack(state):
  info('=== Stack ===')

  stacks = [pg for pg in state.get_child('machine').get_child('memory').get_page_states() if pg.stack == 1]

  sps = {}
  for cs in state.get_child('machine').get_core_states():
    sps[ducky.mm.segment_addr_to_addr(cs.registers[Registers.DS], cs.registers[Registers.SP])] = '#%i:#%i' % (cs.cpuid, cs.coreid)

  for pg in stacks:
    pg_address = pg.index * PAGE_SIZE
    pg_segment = ducky.mm.addr_to_segment(pg_address)

    info('=== Page %s - %s %s ===', pg.index, UINT8_FMT(pg_segment), ADDR_FMT(pg_address))

    for ri in range(0, 16):
      row = []
      for ci in range(0, 8):
        offset = PAGE_SIZE - 2 - (ci * 16 + ri) * 2
        segment_offset = pg_address + offset

        v = pg.content[offset] | (pg.content[offset + 1] << 8)
        row.append((sps.get(segment_offset, None), v))

      info('  ' + '  '.join(['%s %s' % (' ' if sp is None else '*', ducky.console.WHITE(UINT16_FMT(value)) if value != 0 else ducky.console.GREEN(UINT16_FMT(value))) for sp, value in row]))

    info('')

def show_segments(state):
  info('=== Memory segments ===')

  for s in state.get_child('machine').get_child('memory').segments:
    info('  Segment: %s', UINT8_FMT(s))

    for bs in state.get_child('machine').get_binary_states():
      if s == bs.cs:
        info('    CS of %s', bs.path)
      if s == bs.ds:
        info('    DS of %s', bs.path)

  info('')

def show_pages(state):
  info('=== Memory pages ===')

  for pg in sorted(state.get_child('machine').get_child('memory').get_page_states(), key = lambda x: x.index):
    pg_addr = pg.index * PAGE_SIZE
    pg_segment = ducky.mm.addr_to_segment(pg_addr)

    for bs in state.get_child('machine').get_binary_states():
      if pg_segment == bs.cs:
        break
      if pg_segment == bs.ds:
        break

    info('  Page #%i (segment %s)', pg.index, UINT8_FMT(pg_segment))
    info('    Flags: %s%s%s%s', 'r' if pg.read == 1 else '-', 'w' if pg.write == 1 else '-', 'x' if pg.execute == 1 else '-', 'd' if pg.dirty == 1 else '-')

    CPR = 32

    for i in range(0, 256 / CPR):
      s = []
      t = []

      for b in pg.content[CPR * i:CPR * (i + 1)]:
        c = '%02X' % b
        s.append(ducky.console.GREEN(c) if b == 0 else ducky.console.WHITE(c))

        c = chr(b)
        if c in string.printable[0:-5]:
          c = '%%' if c == '%' else (' ' + c)
          t.append(c)

        elif b == 10:
          t.append('\\n')

        elif b == 13:
          t.append('\\r')

        else:
          t.append('  ')

      info('    ' + ADDR_FMT(pg_addr + i * CPR) + ': ' + ' '.join(s))
      info('              ' + ' '.join(t))

      row_symbols = []
      for j in range(pg_addr + i * CPR, pg_addr + i * CPR + CPR):
        if j not in bs.symbols:
          continue

        row_symbols.append((j - (pg_addr + i * CPR)) * 3 * ' ' + '^' + ', '.join(bs.symbols[j]))

      for symbol in row_symbols:
        info('              ' + symbol)

    info('')

def load_binary_symbols(vs, bs):
  bs.raw_binary = ducky.mm.binary.File(bs.path, 'r')
  bs.raw_binary.load()

  bs.symbols = {}
  for i in range(0, bs.raw_binary.get_header().sections):
    s_header, s_content = bs.raw_binary.get_section(i)

    if s_header.type != ducky.mm.binary.SectionTypes.SYMBOLS:
      continue

    for entry in s_content:
      _header, _content = bs.raw_binary.get_section(entry.section)

      segment = bs.cs if _header.type == ducky.mm.binary.SectionTypes.TEXT else bs.ds

      symbol_name = bs.raw_binary.string_table.get_string(entry.name)
      symbol_address = ducky.mm.segment_addr_to_addr(segment, entry.address)

      if symbol_address not in bs.symbols:
        bs.symbols[symbol_address] = []
      bs.symbols[symbol_address].append(symbol_name)

def main():
  parser = optparse.OptionParser()

  parser.add_option('-d', dest = 'debug', action = 'store_true', default = False, help = 'Debug mode')

  parser.add_option('-i', dest = 'file_in', default = None, help = 'Input file')

  parser.add_option('-H',         dest = 'header',   default = False, action = 'store_true', help = 'Show file header')
  parser.add_option('-C',         dest = 'cores',    default = False, action = 'store_true', help = 'Show cores')
  parser.add_option('-M',         dest = 'memory',   default = False, action = 'store_true', help = 'Show memory')
  parser.add_option('--segments', dest = 'segments', default = False, action = 'store_true', help = 'Show segments')
  parser.add_option('--pages',    dest = 'pages',    default = False, action = 'store_true', help = 'Show pages')
  parser.add_option('-b',         dest = 'binaries', default = False, action = 'store_true', help = 'Show binaries')
  parser.add_option('-s',         dest = 'stack',    default = False, action = 'store_true', help = 'Show stack content')
  parser.add_option('-a',         dest = 'all',      default = False, action = 'store_true', help = 'All of above')

  options, args = parser.parse_args()

  ducky.util.CONSOLE = ducky.console.Console(None, sys.stdin, sys.stdout)
  ducky.util.CONSOLE.set_quiet_mode(not options.debug)

  if not options.file_in:
    parser.print_help()
    sys.exit(1)

  if options.all:
    options.header = options.cores = options.memory = options.segments = options.pages = options.binaries = options.stack = True

  info('Input file: %s', options.file_in)

  with ducky.snapshot.CoreDumpFile(options.file_in, 'r') as f_in:
    state = f_in.load()

    for bs in state.get_child('machine').get_binary_states():
      load_binary_symbols(state, bs)

    info('')

    if options.header:
      show_header(state)

    if options.binaries:
      show_binaries(state)

    if options.cores:
      show_cores(state)

    if options.memory:
      show_memory(state)

    if options.segments:
      show_segments(state)

    if options.stack:
      show_stack(state)

    if options.pages:
      show_pages(state)

if __name__ == '__main__':
  main()
